// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: bitcoin/protocol/interface.proto

#ifndef PROTOBUF_bitcoin_2fprotocol_2finterface_2eproto__INCLUDED
#define PROTOBUF_bitcoin_2fprotocol_2finterface_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2006000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2006000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include <bitcoin/protocol/define.hpp>
// @@protoc_insertion_point(includes)

namespace libbitcoin {
namespace protocol {

// Internal implementation detail -- do not call these.
void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

class block_header;
class point;
class tx_input;
class tx_output;
class tx;
class block;
class filter;
class block_id;
class block_location;
class tx_hash_result;
class tx_result;
class output;
class utxo_result;
class block_headers_request;
class transactions_request;
class request;
class response;
class response_block_headers;
class response_transactions;

enum filters {
  ADDRESS = 1,
  TRANSACTION = 2,
  STEALTH = 3
};
BCP_API bool filters_IsValid(int value);
const filters filters_MIN = ADDRESS;
const filters filters_MAX = STEALTH;
const int filters_ARRAYSIZE = filters_MAX + 1;

BCP_API const ::google::protobuf::EnumDescriptor* filters_descriptor();
inline const ::std::string& filters_Name(filters value) {
  return ::google::protobuf::internal::NameOfEnum(
    filters_descriptor(), value);
}
inline bool filters_Parse(
    const ::std::string& name, filters* value) {
  return ::google::protobuf::internal::ParseNamedEnum<filters>(
    filters_descriptor(), name, value);
}
enum transaction_results {
  TX_HASH = 1,
  TX_RESULT = 2,
  UTXO_RESULT = 3
};
BCP_API bool transaction_results_IsValid(int value);
const transaction_results transaction_results_MIN = TX_HASH;
const transaction_results transaction_results_MAX = UTXO_RESULT;
const int transaction_results_ARRAYSIZE = transaction_results_MAX + 1;

BCP_API const ::google::protobuf::EnumDescriptor* transaction_results_descriptor();
inline const ::std::string& transaction_results_Name(transaction_results value) {
  return ::google::protobuf::internal::NameOfEnum(
    transaction_results_descriptor(), value);
}
inline bool transaction_results_Parse(
    const ::std::string& name, transaction_results* value) {
  return ::google::protobuf::internal::ParseNamedEnum<transaction_results>(
    transaction_results_descriptor(), name, value);
}
enum locations {
  NONE = 0,
  BLOCK = 1,
  MERKLE = 2
};
BCP_API bool locations_IsValid(int value);
const locations locations_MIN = NONE;
const locations locations_MAX = MERKLE;
const int locations_ARRAYSIZE = locations_MAX + 1;

BCP_API const ::google::protobuf::EnumDescriptor* locations_descriptor();
inline const ::std::string& locations_Name(locations value) {
  return ::google::protobuf::internal::NameOfEnum(
    locations_descriptor(), value);
}
inline bool locations_Parse(
    const ::std::string& name, locations* value) {
  return ::google::protobuf::internal::ParseNamedEnum<locations>(
    locations_descriptor(), name, value);
}
// ===================================================================

class BCP_API block_header : public ::google::protobuf::Message {
 public:
  block_header();
  virtual ~block_header();

  block_header(const block_header& from);

  inline block_header& operator=(const block_header& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const block_header& default_instance();

  void Swap(block_header* other);

  // implements Message ----------------------------------------------

  block_header* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const block_header& from);
  void MergeFrom(const block_header& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required bytes previous_block_hash = 2;
  inline bool has_previous_block_hash() const;
  inline void clear_previous_block_hash();
  static const int kPreviousBlockHashFieldNumber = 2;
  inline const ::std::string& previous_block_hash() const;
  inline void set_previous_block_hash(const ::std::string& value);
  inline void set_previous_block_hash(const char* value);
  inline void set_previous_block_hash(const void* value, size_t size);
  inline ::std::string* mutable_previous_block_hash();
  inline ::std::string* release_previous_block_hash();
  inline void set_allocated_previous_block_hash(::std::string* previous_block_hash);

  // required bytes merkle_root = 3;
  inline bool has_merkle_root() const;
  inline void clear_merkle_root();
  static const int kMerkleRootFieldNumber = 3;
  inline const ::std::string& merkle_root() const;
  inline void set_merkle_root(const ::std::string& value);
  inline void set_merkle_root(const char* value);
  inline void set_merkle_root(const void* value, size_t size);
  inline ::std::string* mutable_merkle_root();
  inline ::std::string* release_merkle_root();
  inline void set_allocated_merkle_root(::std::string* merkle_root);

  // required uint32 timestamp = 4;
  inline bool has_timestamp() const;
  inline void clear_timestamp();
  static const int kTimestampFieldNumber = 4;
  inline ::google::protobuf::uint32 timestamp() const;
  inline void set_timestamp(::google::protobuf::uint32 value);

  // required uint32 bits = 5;
  inline bool has_bits() const;
  inline void clear_bits();
  static const int kBitsFieldNumber = 5;
  inline ::google::protobuf::uint32 bits() const;
  inline void set_bits(::google::protobuf::uint32 value);

  // required uint32 nonce = 6;
  inline bool has_nonce() const;
  inline void clear_nonce();
  static const int kNonceFieldNumber = 6;
  inline ::google::protobuf::uint32 nonce() const;
  inline void set_nonce(::google::protobuf::uint32 value);

  // required uint64 tx_count = 7;
  inline bool has_tx_count() const;
  inline void clear_tx_count();
  static const int kTxCountFieldNumber = 7;
  inline ::google::protobuf::uint64 tx_count() const;
  inline void set_tx_count(::google::protobuf::uint64 value);

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.block_header)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_previous_block_hash();
  inline void clear_has_previous_block_hash();
  inline void set_has_merkle_root();
  inline void clear_has_merkle_root();
  inline void set_has_timestamp();
  inline void clear_has_timestamp();
  inline void set_has_bits();
  inline void clear_has_bits();
  inline void set_has_nonce();
  inline void clear_has_nonce();
  inline void set_has_tx_count();
  inline void clear_has_tx_count();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* previous_block_hash_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 timestamp_;
  ::std::string* merkle_root_;
  ::google::protobuf::uint32 bits_;
  ::google::protobuf::uint32 nonce_;
  ::google::protobuf::uint64 tx_count_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static block_header* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API point : public ::google::protobuf::Message {
 public:
  point();
  virtual ~point();

  point(const point& from);

  inline point& operator=(const point& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const point& default_instance();

  void Swap(point* other);

  // implements Message ----------------------------------------------

  point* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const point& from);
  void MergeFrom(const point& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // required uint32 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.point)
 private:
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* hash_;
  ::google::protobuf::uint32 index_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static point* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API tx_input : public ::google::protobuf::Message {
 public:
  tx_input();
  virtual ~tx_input();

  tx_input(const tx_input& from);

  inline tx_input& operator=(const tx_input& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tx_input& default_instance();

  void Swap(tx_input* other);

  // implements Message ----------------------------------------------

  tx_input* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tx_input& from);
  void MergeFrom(const tx_input& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .libbitcoin.protocol.point previous_output = 1;
  inline bool has_previous_output() const;
  inline void clear_previous_output();
  static const int kPreviousOutputFieldNumber = 1;
  inline const ::libbitcoin::protocol::point& previous_output() const;
  inline ::libbitcoin::protocol::point* mutable_previous_output();
  inline ::libbitcoin::protocol::point* release_previous_output();
  inline void set_allocated_previous_output(::libbitcoin::protocol::point* previous_output);

  // required bytes script = 2;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 2;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const void* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  inline void set_allocated_script(::std::string* script);

  // required uint32 sequence = 3;
  inline bool has_sequence() const;
  inline void clear_sequence();
  static const int kSequenceFieldNumber = 3;
  inline ::google::protobuf::uint32 sequence() const;
  inline void set_sequence(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.tx_input)
 private:
  inline void set_has_previous_output();
  inline void clear_has_previous_output();
  inline void set_has_script();
  inline void clear_has_script();
  inline void set_has_sequence();
  inline void clear_has_sequence();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::libbitcoin::protocol::point* previous_output_;
  ::std::string* script_;
  ::google::protobuf::uint32 sequence_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static tx_input* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API tx_output : public ::google::protobuf::Message {
 public:
  tx_output();
  virtual ~tx_output();

  tx_output(const tx_output& from);

  inline tx_output& operator=(const tx_output& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tx_output& default_instance();

  void Swap(tx_output* other);

  // implements Message ----------------------------------------------

  tx_output* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tx_output& from);
  void MergeFrom(const tx_output& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint64 value = 1;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 1;
  inline ::google::protobuf::uint64 value() const;
  inline void set_value(::google::protobuf::uint64 value);

  // required bytes script = 2;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 2;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const void* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  inline void set_allocated_script(::std::string* script);

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.tx_output)
 private:
  inline void set_has_value();
  inline void clear_has_value();
  inline void set_has_script();
  inline void clear_has_script();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 value_;
  ::std::string* script_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static tx_output* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API tx : public ::google::protobuf::Message {
 public:
  tx();
  virtual ~tx();

  tx(const tx& from);

  inline tx& operator=(const tx& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tx& default_instance();

  void Swap(tx* other);

  // implements Message ----------------------------------------------

  tx* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tx& from);
  void MergeFrom(const tx& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline ::google::protobuf::uint32 version() const;
  inline void set_version(::google::protobuf::uint32 value);

  // required uint32 locktime = 2;
  inline bool has_locktime() const;
  inline void clear_locktime();
  static const int kLocktimeFieldNumber = 2;
  inline ::google::protobuf::uint32 locktime() const;
  inline void set_locktime(::google::protobuf::uint32 value);

  // repeated .libbitcoin.protocol.tx_input inputs = 3;
  inline int inputs_size() const;
  inline void clear_inputs();
  static const int kInputsFieldNumber = 3;
  inline const ::libbitcoin::protocol::tx_input& inputs(int index) const;
  inline ::libbitcoin::protocol::tx_input* mutable_inputs(int index);
  inline ::libbitcoin::protocol::tx_input* add_inputs();
  inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_input >&
      inputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_input >*
      mutable_inputs();

  // repeated .libbitcoin.protocol.tx_output outputs = 4;
  inline int outputs_size() const;
  inline void clear_outputs();
  static const int kOutputsFieldNumber = 4;
  inline const ::libbitcoin::protocol::tx_output& outputs(int index) const;
  inline ::libbitcoin::protocol::tx_output* mutable_outputs(int index);
  inline ::libbitcoin::protocol::tx_output* add_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_output >&
      outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_output >*
      mutable_outputs();

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.tx)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_locktime();
  inline void clear_has_locktime();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 version_;
  ::google::protobuf::uint32 locktime_;
  ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_input > inputs_;
  ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_output > outputs_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static tx* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API block : public ::google::protobuf::Message {
 public:
  block();
  virtual ~block();

  block(const block& from);

  inline block& operator=(const block& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const block& default_instance();

  void Swap(block* other);

  // implements Message ----------------------------------------------

  block* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const block& from);
  void MergeFrom(const block& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .libbitcoin.protocol.block_header header = 1;
  inline bool has_header() const;
  inline void clear_header();
  static const int kHeaderFieldNumber = 1;
  inline const ::libbitcoin::protocol::block_header& header() const;
  inline ::libbitcoin::protocol::block_header* mutable_header();
  inline ::libbitcoin::protocol::block_header* release_header();
  inline void set_allocated_header(::libbitcoin::protocol::block_header* header);

  // repeated .libbitcoin.protocol.tx transactions = 2;
  inline int transactions_size() const;
  inline void clear_transactions();
  static const int kTransactionsFieldNumber = 2;
  inline const ::libbitcoin::protocol::tx& transactions(int index) const;
  inline ::libbitcoin::protocol::tx* mutable_transactions(int index);
  inline ::libbitcoin::protocol::tx* add_transactions();
  inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx >&
      transactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx >*
      mutable_transactions();

  // repeated bytes tree = 3;
  inline int tree_size() const;
  inline void clear_tree();
  static const int kTreeFieldNumber = 3;
  inline const ::std::string& tree(int index) const;
  inline ::std::string* mutable_tree(int index);
  inline void set_tree(int index, const ::std::string& value);
  inline void set_tree(int index, const char* value);
  inline void set_tree(int index, const void* value, size_t size);
  inline ::std::string* add_tree();
  inline void add_tree(const ::std::string& value);
  inline void add_tree(const char* value);
  inline void add_tree(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& tree() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_tree();

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.block)
 private:
  inline void set_has_header();
  inline void clear_has_header();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::libbitcoin::protocol::block_header* header_;
  ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx > transactions_;
  ::google::protobuf::RepeatedPtrField< ::std::string> tree_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static block* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API filter : public ::google::protobuf::Message {
 public:
  filter();
  virtual ~filter();

  filter(const filter& from);

  inline filter& operator=(const filter& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const filter& default_instance();

  void Swap(filter* other);

  // implements Message ----------------------------------------------

  filter* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const filter& from);
  void MergeFrom(const filter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .libbitcoin.protocol.filters filter_type = 1;
  inline bool has_filter_type() const;
  inline void clear_filter_type();
  static const int kFilterTypeFieldNumber = 1;
  inline ::libbitcoin::protocol::filters filter_type() const;
  inline void set_filter_type(::libbitcoin::protocol::filters value);

  // optional uint32 bits = 2;
  inline bool has_bits() const;
  inline void clear_bits();
  static const int kBitsFieldNumber = 2;
  inline ::google::protobuf::uint32 bits() const;
  inline void set_bits(::google::protobuf::uint32 value);

  // required bytes prefix = 3;
  inline bool has_prefix() const;
  inline void clear_prefix();
  static const int kPrefixFieldNumber = 3;
  inline const ::std::string& prefix() const;
  inline void set_prefix(const ::std::string& value);
  inline void set_prefix(const char* value);
  inline void set_prefix(const void* value, size_t size);
  inline ::std::string* mutable_prefix();
  inline ::std::string* release_prefix();
  inline void set_allocated_prefix(::std::string* prefix);

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.filter)
 private:
  inline void set_has_filter_type();
  inline void clear_has_filter_type();
  inline void set_has_bits();
  inline void clear_has_bits();
  inline void set_has_prefix();
  inline void clear_has_prefix();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  int filter_type_;
  ::google::protobuf::uint32 bits_;
  ::std::string* prefix_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static filter* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API block_id : public ::google::protobuf::Message {
 public:
  block_id();
  virtual ~block_id();

  block_id(const block_id& from);

  inline block_id& operator=(const block_id& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const block_id& default_instance();

  void Swap(block_id* other);

  // implements Message ----------------------------------------------

  block_id* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const block_id& from);
  void MergeFrom(const block_id& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional uint32 height = 1;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 1;
  inline ::google::protobuf::uint32 height() const;
  inline void set_height(::google::protobuf::uint32 value);

  // optional bytes hash = 2;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 2;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.block_id)
 private:
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_hash();
  inline void clear_has_hash();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* hash_;
  ::google::protobuf::uint32 height_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static block_id* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API block_location : public ::google::protobuf::Message {
 public:
  block_location();
  virtual ~block_location();

  block_location(const block_location& from);

  inline block_location& operator=(const block_location& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const block_location& default_instance();

  void Swap(block_location* other);

  // implements Message ----------------------------------------------

  block_location* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const block_location& from);
  void MergeFrom(const block_location& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .libbitcoin.protocol.block_id identity = 1;
  inline bool has_identity() const;
  inline void clear_identity();
  static const int kIdentityFieldNumber = 1;
  inline const ::libbitcoin::protocol::block_id& identity() const;
  inline ::libbitcoin::protocol::block_id* mutable_identity();
  inline ::libbitcoin::protocol::block_id* release_identity();
  inline void set_allocated_identity(::libbitcoin::protocol::block_id* identity);

  // optional uint64 index = 2;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 2;
  inline ::google::protobuf::uint64 index() const;
  inline void set_index(::google::protobuf::uint64 value);

  // repeated bytes branch = 3;
  inline int branch_size() const;
  inline void clear_branch();
  static const int kBranchFieldNumber = 3;
  inline const ::std::string& branch(int index) const;
  inline ::std::string* mutable_branch(int index);
  inline void set_branch(int index, const ::std::string& value);
  inline void set_branch(int index, const char* value);
  inline void set_branch(int index, const void* value, size_t size);
  inline ::std::string* add_branch();
  inline void add_branch(const ::std::string& value);
  inline void add_branch(const char* value);
  inline void add_branch(const void* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& branch() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_branch();

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.block_location)
 private:
  inline void set_has_identity();
  inline void clear_has_identity();
  inline void set_has_index();
  inline void clear_has_index();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::libbitcoin::protocol::block_id* identity_;
  ::google::protobuf::uint64 index_;
  ::google::protobuf::RepeatedPtrField< ::std::string> branch_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static block_location* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API tx_hash_result : public ::google::protobuf::Message {
 public:
  tx_hash_result();
  virtual ~tx_hash_result();

  tx_hash_result(const tx_hash_result& from);

  inline tx_hash_result& operator=(const tx_hash_result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tx_hash_result& default_instance();

  void Swap(tx_hash_result* other);

  // implements Message ----------------------------------------------

  tx_hash_result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tx_hash_result& from);
  void MergeFrom(const tx_hash_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes hash = 1;
  inline bool has_hash() const;
  inline void clear_hash();
  static const int kHashFieldNumber = 1;
  inline const ::std::string& hash() const;
  inline void set_hash(const ::std::string& value);
  inline void set_hash(const char* value);
  inline void set_hash(const void* value, size_t size);
  inline ::std::string* mutable_hash();
  inline ::std::string* release_hash();
  inline void set_allocated_hash(::std::string* hash);

  // required .libbitcoin.protocol.block_location location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::libbitcoin::protocol::block_location& location() const;
  inline ::libbitcoin::protocol::block_location* mutable_location();
  inline ::libbitcoin::protocol::block_location* release_location();
  inline void set_allocated_location(::libbitcoin::protocol::block_location* location);

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.tx_hash_result)
 private:
  inline void set_has_hash();
  inline void clear_has_hash();
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* hash_;
  ::libbitcoin::protocol::block_location* location_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static tx_hash_result* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API tx_result : public ::google::protobuf::Message {
 public:
  tx_result();
  virtual ~tx_result();

  tx_result(const tx_result& from);

  inline tx_result& operator=(const tx_result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const tx_result& default_instance();

  void Swap(tx_result* other);

  // implements Message ----------------------------------------------

  tx_result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const tx_result& from);
  void MergeFrom(const tx_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .libbitcoin.protocol.tx transaction = 1;
  inline bool has_transaction() const;
  inline void clear_transaction();
  static const int kTransactionFieldNumber = 1;
  inline const ::libbitcoin::protocol::tx& transaction() const;
  inline ::libbitcoin::protocol::tx* mutable_transaction();
  inline ::libbitcoin::protocol::tx* release_transaction();
  inline void set_allocated_transaction(::libbitcoin::protocol::tx* transaction);

  // required .libbitcoin.protocol.block_location location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::libbitcoin::protocol::block_location& location() const;
  inline ::libbitcoin::protocol::block_location* mutable_location();
  inline ::libbitcoin::protocol::block_location* release_location();
  inline void set_allocated_location(::libbitcoin::protocol::block_location* location);

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.tx_result)
 private:
  inline void set_has_transaction();
  inline void clear_has_transaction();
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::libbitcoin::protocol::tx* transaction_;
  ::libbitcoin::protocol::block_location* location_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static tx_result* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API output : public ::google::protobuf::Message {
 public:
  output();
  virtual ~output();

  output(const output& from);

  inline output& operator=(const output& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const output& default_instance();

  void Swap(output* other);

  // implements Message ----------------------------------------------

  output* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const output& from);
  void MergeFrom(const output& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 index = 1;
  inline bool has_index() const;
  inline void clear_index();
  static const int kIndexFieldNumber = 1;
  inline ::google::protobuf::uint32 index() const;
  inline void set_index(::google::protobuf::uint32 value);

  // required uint64 satoshis = 2;
  inline bool has_satoshis() const;
  inline void clear_satoshis();
  static const int kSatoshisFieldNumber = 2;
  inline ::google::protobuf::uint64 satoshis() const;
  inline void set_satoshis(::google::protobuf::uint64 value);

  // required bytes script = 3;
  inline bool has_script() const;
  inline void clear_script();
  static const int kScriptFieldNumber = 3;
  inline const ::std::string& script() const;
  inline void set_script(const ::std::string& value);
  inline void set_script(const char* value);
  inline void set_script(const void* value, size_t size);
  inline ::std::string* mutable_script();
  inline ::std::string* release_script();
  inline void set_allocated_script(::std::string* script);

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.output)
 private:
  inline void set_has_index();
  inline void clear_has_index();
  inline void set_has_satoshis();
  inline void clear_has_satoshis();
  inline void set_has_script();
  inline void clear_has_script();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint64 satoshis_;
  ::std::string* script_;
  ::google::protobuf::uint32 index_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static output* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API utxo_result : public ::google::protobuf::Message {
 public:
  utxo_result();
  virtual ~utxo_result();

  utxo_result(const utxo_result& from);

  inline utxo_result& operator=(const utxo_result& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const utxo_result& default_instance();

  void Swap(utxo_result* other);

  // implements Message ----------------------------------------------

  utxo_result* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const utxo_result& from);
  void MergeFrom(const utxo_result& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required bytes tx_hash = 1;
  inline bool has_tx_hash() const;
  inline void clear_tx_hash();
  static const int kTxHashFieldNumber = 1;
  inline const ::std::string& tx_hash() const;
  inline void set_tx_hash(const ::std::string& value);
  inline void set_tx_hash(const char* value);
  inline void set_tx_hash(const void* value, size_t size);
  inline ::std::string* mutable_tx_hash();
  inline ::std::string* release_tx_hash();
  inline void set_allocated_tx_hash(::std::string* tx_hash);

  // required .libbitcoin.protocol.block_location location = 2;
  inline bool has_location() const;
  inline void clear_location();
  static const int kLocationFieldNumber = 2;
  inline const ::libbitcoin::protocol::block_location& location() const;
  inline ::libbitcoin::protocol::block_location* mutable_location();
  inline ::libbitcoin::protocol::block_location* release_location();
  inline void set_allocated_location(::libbitcoin::protocol::block_location* location);

  // repeated .libbitcoin.protocol.output outputs = 3;
  inline int outputs_size() const;
  inline void clear_outputs();
  static const int kOutputsFieldNumber = 3;
  inline const ::libbitcoin::protocol::output& outputs(int index) const;
  inline ::libbitcoin::protocol::output* mutable_outputs(int index);
  inline ::libbitcoin::protocol::output* add_outputs();
  inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::output >&
      outputs() const;
  inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::output >*
      mutable_outputs();

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.utxo_result)
 private:
  inline void set_has_tx_hash();
  inline void clear_has_tx_hash();
  inline void set_has_location();
  inline void clear_has_location();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::std::string* tx_hash_;
  ::libbitcoin::protocol::block_location* location_;
  ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::output > outputs_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static utxo_result* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API block_headers_request : public ::google::protobuf::Message {
 public:
  block_headers_request();
  virtual ~block_headers_request();

  block_headers_request(const block_headers_request& from);

  inline block_headers_request& operator=(const block_headers_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const block_headers_request& default_instance();

  void Swap(block_headers_request* other);

  // implements Message ----------------------------------------------

  block_headers_request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const block_headers_request& from);
  void MergeFrom(const block_headers_request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .libbitcoin.protocol.block_id start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline const ::libbitcoin::protocol::block_id& start() const;
  inline ::libbitcoin::protocol::block_id* mutable_start();
  inline ::libbitcoin::protocol::block_id* release_start();
  inline void set_allocated_start(::libbitcoin::protocol::block_id* start);

  // optional uint32 results_per_page = 2;
  inline bool has_results_per_page() const;
  inline void clear_results_per_page();
  static const int kResultsPerPageFieldNumber = 2;
  inline ::google::protobuf::uint32 results_per_page() const;
  inline void set_results_per_page(::google::protobuf::uint32 value);

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.block_headers_request)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_results_per_page();
  inline void clear_has_results_per_page();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::libbitcoin::protocol::block_id* start_;
  ::google::protobuf::uint32 results_per_page_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static block_headers_request* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API transactions_request : public ::google::protobuf::Message {
 public:
  transactions_request();
  virtual ~transactions_request();

  transactions_request(const transactions_request& from);

  inline transactions_request& operator=(const transactions_request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const transactions_request& default_instance();

  void Swap(transactions_request* other);

  // implements Message ----------------------------------------------

  transactions_request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const transactions_request& from);
  void MergeFrom(const transactions_request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .libbitcoin.protocol.block_id start = 1;
  inline bool has_start() const;
  inline void clear_start();
  static const int kStartFieldNumber = 1;
  inline const ::libbitcoin::protocol::block_id& start() const;
  inline ::libbitcoin::protocol::block_id* mutable_start();
  inline ::libbitcoin::protocol::block_id* release_start();
  inline void set_allocated_start(::libbitcoin::protocol::block_id* start);

  // optional uint32 results_per_page = 2;
  inline bool has_results_per_page() const;
  inline void clear_results_per_page();
  static const int kResultsPerPageFieldNumber = 2;
  inline ::google::protobuf::uint32 results_per_page() const;
  inline void set_results_per_page(::google::protobuf::uint32 value);

  // repeated .libbitcoin.protocol.filter query = 3;
  inline int query_size() const;
  inline void clear_query();
  static const int kQueryFieldNumber = 3;
  inline const ::libbitcoin::protocol::filter& query(int index) const;
  inline ::libbitcoin::protocol::filter* mutable_query(int index);
  inline ::libbitcoin::protocol::filter* add_query();
  inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::filter >&
      query() const;
  inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::filter >*
      mutable_query();

  // optional .libbitcoin.protocol.transaction_results result_type = 4 [default = TX_HASH];
  inline bool has_result_type() const;
  inline void clear_result_type();
  static const int kResultTypeFieldNumber = 4;
  inline ::libbitcoin::protocol::transaction_results result_type() const;
  inline void set_result_type(::libbitcoin::protocol::transaction_results value);

  // optional .libbitcoin.protocol.locations location_type = 5 [default = NONE];
  inline bool has_location_type() const;
  inline void clear_location_type();
  static const int kLocationTypeFieldNumber = 5;
  inline ::libbitcoin::protocol::locations location_type() const;
  inline void set_location_type(::libbitcoin::protocol::locations value);

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.transactions_request)
 private:
  inline void set_has_start();
  inline void clear_has_start();
  inline void set_has_results_per_page();
  inline void clear_has_results_per_page();
  inline void set_has_result_type();
  inline void clear_has_result_type();
  inline void set_has_location_type();
  inline void clear_has_location_type();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::libbitcoin::protocol::block_id* start_;
  ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::filter > query_;
  ::google::protobuf::uint32 results_per_page_;
  int result_type_;
  int location_type_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static transactions_request* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API request : public ::google::protobuf::Message {
 public:
  request();
  virtual ~request();

  request(const request& from);

  inline request& operator=(const request& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const request& default_instance();

  enum RequestTypeCase {
    kGetBlockHeaders = 2,
    kGetTransactions = 3,
    kPostTransaction = 4,
    kValidateTransaction = 5,
    kPostBlock = 6,
    kValidateBlock = 7,
    REQUEST_TYPE_NOT_SET = 0,
  };

  void Swap(request* other);

  // implements Message ----------------------------------------------

  request* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const request& from);
  void MergeFrom(const request& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional .libbitcoin.protocol.block_headers_request get_block_headers = 2;
  inline bool has_get_block_headers() const;
  inline void clear_get_block_headers();
  static const int kGetBlockHeadersFieldNumber = 2;
  inline const ::libbitcoin::protocol::block_headers_request& get_block_headers() const;
  inline ::libbitcoin::protocol::block_headers_request* mutable_get_block_headers();
  inline ::libbitcoin::protocol::block_headers_request* release_get_block_headers();
  inline void set_allocated_get_block_headers(::libbitcoin::protocol::block_headers_request* get_block_headers);

  // optional .libbitcoin.protocol.transactions_request get_transactions = 3;
  inline bool has_get_transactions() const;
  inline void clear_get_transactions();
  static const int kGetTransactionsFieldNumber = 3;
  inline const ::libbitcoin::protocol::transactions_request& get_transactions() const;
  inline ::libbitcoin::protocol::transactions_request* mutable_get_transactions();
  inline ::libbitcoin::protocol::transactions_request* release_get_transactions();
  inline void set_allocated_get_transactions(::libbitcoin::protocol::transactions_request* get_transactions);

  // optional .libbitcoin.protocol.tx post_transaction = 4;
  inline bool has_post_transaction() const;
  inline void clear_post_transaction();
  static const int kPostTransactionFieldNumber = 4;
  inline const ::libbitcoin::protocol::tx& post_transaction() const;
  inline ::libbitcoin::protocol::tx* mutable_post_transaction();
  inline ::libbitcoin::protocol::tx* release_post_transaction();
  inline void set_allocated_post_transaction(::libbitcoin::protocol::tx* post_transaction);

  // optional .libbitcoin.protocol.tx validate_transaction = 5;
  inline bool has_validate_transaction() const;
  inline void clear_validate_transaction();
  static const int kValidateTransactionFieldNumber = 5;
  inline const ::libbitcoin::protocol::tx& validate_transaction() const;
  inline ::libbitcoin::protocol::tx* mutable_validate_transaction();
  inline ::libbitcoin::protocol::tx* release_validate_transaction();
  inline void set_allocated_validate_transaction(::libbitcoin::protocol::tx* validate_transaction);

  // optional .libbitcoin.protocol.block post_block = 6;
  inline bool has_post_block() const;
  inline void clear_post_block();
  static const int kPostBlockFieldNumber = 6;
  inline const ::libbitcoin::protocol::block& post_block() const;
  inline ::libbitcoin::protocol::block* mutable_post_block();
  inline ::libbitcoin::protocol::block* release_post_block();
  inline void set_allocated_post_block(::libbitcoin::protocol::block* post_block);

  // optional .libbitcoin.protocol.block validate_block = 7;
  inline bool has_validate_block() const;
  inline void clear_validate_block();
  static const int kValidateBlockFieldNumber = 7;
  inline const ::libbitcoin::protocol::block& validate_block() const;
  inline ::libbitcoin::protocol::block* mutable_validate_block();
  inline ::libbitcoin::protocol::block* release_validate_block();
  inline void set_allocated_validate_block(::libbitcoin::protocol::block* validate_block);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(request)
  inline RequestTypeCase request_type_case() const;
  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.request)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_get_block_headers();
  inline void set_has_get_transactions();
  inline void set_has_post_transaction();
  inline void set_has_validate_transaction();
  inline void set_has_post_block();
  inline void set_has_validate_block();

  inline bool has_request_type();
  void clear_request_type();
  inline void clear_has_request_type();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  union RequestTypeUnion {
    ::libbitcoin::protocol::block_headers_request* get_block_headers_;
    ::libbitcoin::protocol::transactions_request* get_transactions_;
    ::libbitcoin::protocol::tx* post_transaction_;
    ::libbitcoin::protocol::tx* validate_transaction_;
    ::libbitcoin::protocol::block* post_block_;
    ::libbitcoin::protocol::block* validate_block_;
  } request_type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static request* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API response_block_headers : public ::google::protobuf::Message {
 public:
  response_block_headers();
  virtual ~response_block_headers();

  response_block_headers(const response_block_headers& from);

  inline response_block_headers& operator=(const response_block_headers& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const response_block_headers& default_instance();

  void Swap(response_block_headers* other);

  // implements Message ----------------------------------------------

  response_block_headers* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const response_block_headers& from);
  void MergeFrom(const response_block_headers& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .libbitcoin.protocol.block_id next = 1;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 1;
  inline const ::libbitcoin::protocol::block_id& next() const;
  inline ::libbitcoin::protocol::block_id* mutable_next();
  inline ::libbitcoin::protocol::block_id* release_next();
  inline void set_allocated_next(::libbitcoin::protocol::block_id* next);

  // optional .libbitcoin.protocol.block_id top = 2;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 2;
  inline const ::libbitcoin::protocol::block_id& top() const;
  inline ::libbitcoin::protocol::block_id* mutable_top();
  inline ::libbitcoin::protocol::block_id* release_top();
  inline void set_allocated_top(::libbitcoin::protocol::block_id* top);

  // repeated .libbitcoin.protocol.block_header headers = 3;
  inline int headers_size() const;
  inline void clear_headers();
  static const int kHeadersFieldNumber = 3;
  inline const ::libbitcoin::protocol::block_header& headers(int index) const;
  inline ::libbitcoin::protocol::block_header* mutable_headers(int index);
  inline ::libbitcoin::protocol::block_header* add_headers();
  inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::block_header >&
      headers() const;
  inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::block_header >*
      mutable_headers();

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.response.block_headers)
 private:
  inline void set_has_next();
  inline void clear_has_next();
  inline void set_has_top();
  inline void clear_has_top();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::libbitcoin::protocol::block_id* next_;
  ::libbitcoin::protocol::block_id* top_;
  ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::block_header > headers_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static response_block_headers* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API response_transactions : public ::google::protobuf::Message {
 public:
  response_transactions();
  virtual ~response_transactions();

  response_transactions(const response_transactions& from);

  inline response_transactions& operator=(const response_transactions& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const response_transactions& default_instance();

  void Swap(response_transactions* other);

  // implements Message ----------------------------------------------

  response_transactions* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const response_transactions& from);
  void MergeFrom(const response_transactions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .libbitcoin.protocol.block_id next = 1;
  inline bool has_next() const;
  inline void clear_next();
  static const int kNextFieldNumber = 1;
  inline const ::libbitcoin::protocol::block_id& next() const;
  inline ::libbitcoin::protocol::block_id* mutable_next();
  inline ::libbitcoin::protocol::block_id* release_next();
  inline void set_allocated_next(::libbitcoin::protocol::block_id* next);

  // optional .libbitcoin.protocol.block_id top = 2;
  inline bool has_top() const;
  inline void clear_top();
  static const int kTopFieldNumber = 2;
  inline const ::libbitcoin::protocol::block_id& top() const;
  inline ::libbitcoin::protocol::block_id* mutable_top();
  inline ::libbitcoin::protocol::block_id* release_top();
  inline void set_allocated_top(::libbitcoin::protocol::block_id* top);

  // repeated .libbitcoin.protocol.tx_hash_result hashes = 3;
  inline int hashes_size() const;
  inline void clear_hashes();
  static const int kHashesFieldNumber = 3;
  inline const ::libbitcoin::protocol::tx_hash_result& hashes(int index) const;
  inline ::libbitcoin::protocol::tx_hash_result* mutable_hashes(int index);
  inline ::libbitcoin::protocol::tx_hash_result* add_hashes();
  inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_hash_result >&
      hashes() const;
  inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_hash_result >*
      mutable_hashes();

  // repeated .libbitcoin.protocol.tx_result transactions = 4;
  inline int transactions_size() const;
  inline void clear_transactions();
  static const int kTransactionsFieldNumber = 4;
  inline const ::libbitcoin::protocol::tx_result& transactions(int index) const;
  inline ::libbitcoin::protocol::tx_result* mutable_transactions(int index);
  inline ::libbitcoin::protocol::tx_result* add_transactions();
  inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_result >&
      transactions() const;
  inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_result >*
      mutable_transactions();

  // repeated .libbitcoin.protocol.utxo_result utxos = 5;
  inline int utxos_size() const;
  inline void clear_utxos();
  static const int kUtxosFieldNumber = 5;
  inline const ::libbitcoin::protocol::utxo_result& utxos(int index) const;
  inline ::libbitcoin::protocol::utxo_result* mutable_utxos(int index);
  inline ::libbitcoin::protocol::utxo_result* add_utxos();
  inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::utxo_result >&
      utxos() const;
  inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::utxo_result >*
      mutable_utxos();

  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.response.transactions)
 private:
  inline void set_has_next();
  inline void clear_has_next();
  inline void set_has_top();
  inline void clear_has_top();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::libbitcoin::protocol::block_id* next_;
  ::libbitcoin::protocol::block_id* top_;
  ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_hash_result > hashes_;
  ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_result > transactions_;
  ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::utxo_result > utxos_;
  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static response_transactions* default_instance_;
};
// -------------------------------------------------------------------

class BCP_API response : public ::google::protobuf::Message {
 public:
  response();
  virtual ~response();

  response(const response& from);

  inline response& operator=(const response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const response& default_instance();

  enum ResponseTypeCase {
    kGetBlockHeadersResponse = 3,
    kGetTransactionsResponse = 4,
    kPostTransactionSucceeded = 5,
    kValidateTransactionSucceeded = 6,
    kPostBlockSucceeded = 7,
    kValidateBlockSucceeded = 8,
    RESPONSE_TYPE_NOT_SET = 0,
  };

  void Swap(response* other);

  // implements Message ----------------------------------------------

  response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const response& from);
  void MergeFrom(const response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:
  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef response_block_headers block_headers;
  typedef response_transactions transactions;

  // accessors -------------------------------------------------------

  // required uint32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::uint32 id() const;
  inline void set_id(::google::protobuf::uint32 value);

  // optional sint32 status = 2;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 2;
  inline ::google::protobuf::int32 status() const;
  inline void set_status(::google::protobuf::int32 value);

  // optional .libbitcoin.protocol.response.block_headers get_block_headers_response = 3;
  inline bool has_get_block_headers_response() const;
  inline void clear_get_block_headers_response();
  static const int kGetBlockHeadersResponseFieldNumber = 3;
  inline const ::libbitcoin::protocol::response_block_headers& get_block_headers_response() const;
  inline ::libbitcoin::protocol::response_block_headers* mutable_get_block_headers_response();
  inline ::libbitcoin::protocol::response_block_headers* release_get_block_headers_response();
  inline void set_allocated_get_block_headers_response(::libbitcoin::protocol::response_block_headers* get_block_headers_response);

  // optional .libbitcoin.protocol.response.transactions get_transactions_response = 4;
  inline bool has_get_transactions_response() const;
  inline void clear_get_transactions_response();
  static const int kGetTransactionsResponseFieldNumber = 4;
  inline const ::libbitcoin::protocol::response_transactions& get_transactions_response() const;
  inline ::libbitcoin::protocol::response_transactions* mutable_get_transactions_response();
  inline ::libbitcoin::protocol::response_transactions* release_get_transactions_response();
  inline void set_allocated_get_transactions_response(::libbitcoin::protocol::response_transactions* get_transactions_response);

  // optional bool post_transaction_succeeded = 5;
  inline bool has_post_transaction_succeeded() const;
  inline void clear_post_transaction_succeeded();
  static const int kPostTransactionSucceededFieldNumber = 5;
  inline bool post_transaction_succeeded() const;
  inline void set_post_transaction_succeeded(bool value);

  // optional bool validate_transaction_succeeded = 6;
  inline bool has_validate_transaction_succeeded() const;
  inline void clear_validate_transaction_succeeded();
  static const int kValidateTransactionSucceededFieldNumber = 6;
  inline bool validate_transaction_succeeded() const;
  inline void set_validate_transaction_succeeded(bool value);

  // optional bool post_block_succeeded = 7;
  inline bool has_post_block_succeeded() const;
  inline void clear_post_block_succeeded();
  static const int kPostBlockSucceededFieldNumber = 7;
  inline bool post_block_succeeded() const;
  inline void set_post_block_succeeded(bool value);

  // optional bool validate_block_succeeded = 8;
  inline bool has_validate_block_succeeded() const;
  inline void clear_validate_block_succeeded();
  static const int kValidateBlockSucceededFieldNumber = 8;
  inline bool validate_block_succeeded() const;
  inline void set_validate_block_succeeded(bool value);

  GOOGLE_PROTOBUF_EXTENSION_ACCESSORS(response)
  inline ResponseTypeCase response_type_case() const;
  // @@protoc_insertion_point(class_scope:libbitcoin.protocol.response)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_status();
  inline void clear_has_status();
  inline void set_has_get_block_headers_response();
  inline void set_has_get_transactions_response();
  inline void set_has_post_transaction_succeeded();
  inline void set_has_validate_transaction_succeeded();
  inline void set_has_post_block_succeeded();
  inline void set_has_validate_block_succeeded();

  inline bool has_response_type();
  void clear_response_type();
  inline void clear_has_response_type();

  ::google::protobuf::internal::ExtensionSet _extensions_;

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::uint32 _has_bits_[1];
  mutable int _cached_size_;
  ::google::protobuf::uint32 id_;
  ::google::protobuf::int32 status_;
  union ResponseTypeUnion {
    ::libbitcoin::protocol::response_block_headers* get_block_headers_response_;
    ::libbitcoin::protocol::response_transactions* get_transactions_response_;
    bool post_transaction_succeeded_;
    bool validate_transaction_succeeded_;
    bool post_block_succeeded_;
    bool validate_block_succeeded_;
  } response_type_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void BCP_API protobuf_AddDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_AssignDesc_bitcoin_2fprotocol_2finterface_2eproto();
  friend void protobuf_ShutdownFile_bitcoin_2fprotocol_2finterface_2eproto();

  void InitAsDefaultInstance();
  static response* default_instance_;
};
// ===================================================================


// ===================================================================

// block_header

// required uint32 version = 1;
inline bool block_header::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void block_header::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void block_header::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void block_header::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 block_header::version() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_header.version)
  return version_;
}
inline void block_header::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.block_header.version)
}

// required bytes previous_block_hash = 2;
inline bool block_header::has_previous_block_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void block_header::set_has_previous_block_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void block_header::clear_has_previous_block_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void block_header::clear_previous_block_hash() {
  if (previous_block_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previous_block_hash_->clear();
  }
  clear_has_previous_block_hash();
}
inline const ::std::string& block_header::previous_block_hash() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_header.previous_block_hash)
  return *previous_block_hash_;
}
inline void block_header::set_previous_block_hash(const ::std::string& value) {
  set_has_previous_block_hash();
  if (previous_block_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previous_block_hash_ = new ::std::string;
  }
  previous_block_hash_->assign(value);
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.block_header.previous_block_hash)
}
inline void block_header::set_previous_block_hash(const char* value) {
  set_has_previous_block_hash();
  if (previous_block_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previous_block_hash_ = new ::std::string;
  }
  previous_block_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:libbitcoin.protocol.block_header.previous_block_hash)
}
inline void block_header::set_previous_block_hash(const void* value, size_t size) {
  set_has_previous_block_hash();
  if (previous_block_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previous_block_hash_ = new ::std::string;
  }
  previous_block_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:libbitcoin.protocol.block_header.previous_block_hash)
}
inline ::std::string* block_header::mutable_previous_block_hash() {
  set_has_previous_block_hash();
  if (previous_block_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    previous_block_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.block_header.previous_block_hash)
  return previous_block_hash_;
}
inline ::std::string* block_header::release_previous_block_hash() {
  clear_has_previous_block_hash();
  if (previous_block_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = previous_block_hash_;
    previous_block_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void block_header::set_allocated_previous_block_hash(::std::string* previous_block_hash) {
  if (previous_block_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete previous_block_hash_;
  }
  if (previous_block_hash) {
    set_has_previous_block_hash();
    previous_block_hash_ = previous_block_hash;
  } else {
    clear_has_previous_block_hash();
    previous_block_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.block_header.previous_block_hash)
}

// required bytes merkle_root = 3;
inline bool block_header::has_merkle_root() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void block_header::set_has_merkle_root() {
  _has_bits_[0] |= 0x00000004u;
}
inline void block_header::clear_has_merkle_root() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void block_header::clear_merkle_root() {
  if (merkle_root_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_root_->clear();
  }
  clear_has_merkle_root();
}
inline const ::std::string& block_header::merkle_root() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_header.merkle_root)
  return *merkle_root_;
}
inline void block_header::set_merkle_root(const ::std::string& value) {
  set_has_merkle_root();
  if (merkle_root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_root_ = new ::std::string;
  }
  merkle_root_->assign(value);
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.block_header.merkle_root)
}
inline void block_header::set_merkle_root(const char* value) {
  set_has_merkle_root();
  if (merkle_root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_root_ = new ::std::string;
  }
  merkle_root_->assign(value);
  // @@protoc_insertion_point(field_set_char:libbitcoin.protocol.block_header.merkle_root)
}
inline void block_header::set_merkle_root(const void* value, size_t size) {
  set_has_merkle_root();
  if (merkle_root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_root_ = new ::std::string;
  }
  merkle_root_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:libbitcoin.protocol.block_header.merkle_root)
}
inline ::std::string* block_header::mutable_merkle_root() {
  set_has_merkle_root();
  if (merkle_root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    merkle_root_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.block_header.merkle_root)
  return merkle_root_;
}
inline ::std::string* block_header::release_merkle_root() {
  clear_has_merkle_root();
  if (merkle_root_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = merkle_root_;
    merkle_root_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void block_header::set_allocated_merkle_root(::std::string* merkle_root) {
  if (merkle_root_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete merkle_root_;
  }
  if (merkle_root) {
    set_has_merkle_root();
    merkle_root_ = merkle_root;
  } else {
    clear_has_merkle_root();
    merkle_root_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.block_header.merkle_root)
}

// required uint32 timestamp = 4;
inline bool block_header::has_timestamp() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void block_header::set_has_timestamp() {
  _has_bits_[0] |= 0x00000008u;
}
inline void block_header::clear_has_timestamp() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void block_header::clear_timestamp() {
  timestamp_ = 0u;
  clear_has_timestamp();
}
inline ::google::protobuf::uint32 block_header::timestamp() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_header.timestamp)
  return timestamp_;
}
inline void block_header::set_timestamp(::google::protobuf::uint32 value) {
  set_has_timestamp();
  timestamp_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.block_header.timestamp)
}

// required uint32 bits = 5;
inline bool block_header::has_bits() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void block_header::set_has_bits() {
  _has_bits_[0] |= 0x00000010u;
}
inline void block_header::clear_has_bits() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void block_header::clear_bits() {
  bits_ = 0u;
  clear_has_bits();
}
inline ::google::protobuf::uint32 block_header::bits() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_header.bits)
  return bits_;
}
inline void block_header::set_bits(::google::protobuf::uint32 value) {
  set_has_bits();
  bits_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.block_header.bits)
}

// required uint32 nonce = 6;
inline bool block_header::has_nonce() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void block_header::set_has_nonce() {
  _has_bits_[0] |= 0x00000020u;
}
inline void block_header::clear_has_nonce() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void block_header::clear_nonce() {
  nonce_ = 0u;
  clear_has_nonce();
}
inline ::google::protobuf::uint32 block_header::nonce() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_header.nonce)
  return nonce_;
}
inline void block_header::set_nonce(::google::protobuf::uint32 value) {
  set_has_nonce();
  nonce_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.block_header.nonce)
}

// required uint64 tx_count = 7;
inline bool block_header::has_tx_count() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void block_header::set_has_tx_count() {
  _has_bits_[0] |= 0x00000040u;
}
inline void block_header::clear_has_tx_count() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void block_header::clear_tx_count() {
  tx_count_ = GOOGLE_ULONGLONG(0);
  clear_has_tx_count();
}
inline ::google::protobuf::uint64 block_header::tx_count() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_header.tx_count)
  return tx_count_;
}
inline void block_header::set_tx_count(::google::protobuf::uint64 value) {
  set_has_tx_count();
  tx_count_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.block_header.tx_count)
}

// -------------------------------------------------------------------

// point

// required bytes hash = 1;
inline bool point::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void point::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void point::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void point::clear_hash() {
  if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& point::hash() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.point.hash)
  return *hash_;
}
inline void point::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.point.hash)
}
inline void point::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:libbitcoin.protocol.point.hash)
}
inline void point::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:libbitcoin.protocol.point.hash)
}
inline ::std::string* point::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.point.hash)
  return hash_;
}
inline ::std::string* point::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void point::set_allocated_hash(::std::string* hash) {
  if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hash_;
  }
  if (hash) {
    set_has_hash();
    hash_ = hash;
  } else {
    clear_has_hash();
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.point.hash)
}

// required uint32 index = 2;
inline bool point::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void point::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void point::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void point::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 point::index() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.point.index)
  return index_;
}
inline void point::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.point.index)
}

// -------------------------------------------------------------------

// tx_input

// required .libbitcoin.protocol.point previous_output = 1;
inline bool tx_input::has_previous_output() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tx_input::set_has_previous_output() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tx_input::clear_has_previous_output() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tx_input::clear_previous_output() {
  if (previous_output_ != NULL) previous_output_->::libbitcoin::protocol::point::Clear();
  clear_has_previous_output();
}
inline const ::libbitcoin::protocol::point& tx_input::previous_output() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.tx_input.previous_output)
  return previous_output_ != NULL ? *previous_output_ : *default_instance_->previous_output_;
}
inline ::libbitcoin::protocol::point* tx_input::mutable_previous_output() {
  set_has_previous_output();
  if (previous_output_ == NULL) previous_output_ = new ::libbitcoin::protocol::point;
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.tx_input.previous_output)
  return previous_output_;
}
inline ::libbitcoin::protocol::point* tx_input::release_previous_output() {
  clear_has_previous_output();
  ::libbitcoin::protocol::point* temp = previous_output_;
  previous_output_ = NULL;
  return temp;
}
inline void tx_input::set_allocated_previous_output(::libbitcoin::protocol::point* previous_output) {
  delete previous_output_;
  previous_output_ = previous_output;
  if (previous_output) {
    set_has_previous_output();
  } else {
    clear_has_previous_output();
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.tx_input.previous_output)
}

// required bytes script = 2;
inline bool tx_input::has_script() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tx_input::set_has_script() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tx_input::clear_has_script() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tx_input::clear_script() {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& tx_input::script() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.tx_input.script)
  return *script_;
}
inline void tx_input::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(value);
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.tx_input.script)
}
inline void tx_input::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(value);
  // @@protoc_insertion_point(field_set_char:libbitcoin.protocol.tx_input.script)
}
inline void tx_input::set_script(const void* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:libbitcoin.protocol.tx_input.script)
}
inline ::std::string* tx_input::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.tx_input.script)
  return script_;
}
inline ::std::string* tx_input::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void tx_input::set_allocated_script(::std::string* script) {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_;
  }
  if (script) {
    set_has_script();
    script_ = script;
  } else {
    clear_has_script();
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.tx_input.script)
}

// required uint32 sequence = 3;
inline bool tx_input::has_sequence() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void tx_input::set_has_sequence() {
  _has_bits_[0] |= 0x00000004u;
}
inline void tx_input::clear_has_sequence() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void tx_input::clear_sequence() {
  sequence_ = 0u;
  clear_has_sequence();
}
inline ::google::protobuf::uint32 tx_input::sequence() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.tx_input.sequence)
  return sequence_;
}
inline void tx_input::set_sequence(::google::protobuf::uint32 value) {
  set_has_sequence();
  sequence_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.tx_input.sequence)
}

// -------------------------------------------------------------------

// tx_output

// required uint64 value = 1;
inline bool tx_output::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tx_output::set_has_value() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tx_output::clear_has_value() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tx_output::clear_value() {
  value_ = GOOGLE_ULONGLONG(0);
  clear_has_value();
}
inline ::google::protobuf::uint64 tx_output::value() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.tx_output.value)
  return value_;
}
inline void tx_output::set_value(::google::protobuf::uint64 value) {
  set_has_value();
  value_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.tx_output.value)
}

// required bytes script = 2;
inline bool tx_output::has_script() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tx_output::set_has_script() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tx_output::clear_has_script() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tx_output::clear_script() {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& tx_output::script() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.tx_output.script)
  return *script_;
}
inline void tx_output::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(value);
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.tx_output.script)
}
inline void tx_output::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(value);
  // @@protoc_insertion_point(field_set_char:libbitcoin.protocol.tx_output.script)
}
inline void tx_output::set_script(const void* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:libbitcoin.protocol.tx_output.script)
}
inline ::std::string* tx_output::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.tx_output.script)
  return script_;
}
inline ::std::string* tx_output::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void tx_output::set_allocated_script(::std::string* script) {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_;
  }
  if (script) {
    set_has_script();
    script_ = script;
  } else {
    clear_has_script();
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.tx_output.script)
}

// -------------------------------------------------------------------

// tx

// required uint32 version = 1;
inline bool tx::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tx::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tx::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tx::clear_version() {
  version_ = 0u;
  clear_has_version();
}
inline ::google::protobuf::uint32 tx::version() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.tx.version)
  return version_;
}
inline void tx::set_version(::google::protobuf::uint32 value) {
  set_has_version();
  version_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.tx.version)
}

// required uint32 locktime = 2;
inline bool tx::has_locktime() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tx::set_has_locktime() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tx::clear_has_locktime() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tx::clear_locktime() {
  locktime_ = 0u;
  clear_has_locktime();
}
inline ::google::protobuf::uint32 tx::locktime() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.tx.locktime)
  return locktime_;
}
inline void tx::set_locktime(::google::protobuf::uint32 value) {
  set_has_locktime();
  locktime_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.tx.locktime)
}

// repeated .libbitcoin.protocol.tx_input inputs = 3;
inline int tx::inputs_size() const {
  return inputs_.size();
}
inline void tx::clear_inputs() {
  inputs_.Clear();
}
inline const ::libbitcoin::protocol::tx_input& tx::inputs(int index) const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.tx.inputs)
  return inputs_.Get(index);
}
inline ::libbitcoin::protocol::tx_input* tx::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.tx.inputs)
  return inputs_.Mutable(index);
}
inline ::libbitcoin::protocol::tx_input* tx::add_inputs() {
  // @@protoc_insertion_point(field_add:libbitcoin.protocol.tx.inputs)
  return inputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_input >&
tx::inputs() const {
  // @@protoc_insertion_point(field_list:libbitcoin.protocol.tx.inputs)
  return inputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_input >*
tx::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:libbitcoin.protocol.tx.inputs)
  return &inputs_;
}

// repeated .libbitcoin.protocol.tx_output outputs = 4;
inline int tx::outputs_size() const {
  return outputs_.size();
}
inline void tx::clear_outputs() {
  outputs_.Clear();
}
inline const ::libbitcoin::protocol::tx_output& tx::outputs(int index) const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.tx.outputs)
  return outputs_.Get(index);
}
inline ::libbitcoin::protocol::tx_output* tx::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.tx.outputs)
  return outputs_.Mutable(index);
}
inline ::libbitcoin::protocol::tx_output* tx::add_outputs() {
  // @@protoc_insertion_point(field_add:libbitcoin.protocol.tx.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_output >&
tx::outputs() const {
  // @@protoc_insertion_point(field_list:libbitcoin.protocol.tx.outputs)
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_output >*
tx::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:libbitcoin.protocol.tx.outputs)
  return &outputs_;
}

// -------------------------------------------------------------------

// block

// required .libbitcoin.protocol.block_header header = 1;
inline bool block::has_header() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void block::set_has_header() {
  _has_bits_[0] |= 0x00000001u;
}
inline void block::clear_has_header() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void block::clear_header() {
  if (header_ != NULL) header_->::libbitcoin::protocol::block_header::Clear();
  clear_has_header();
}
inline const ::libbitcoin::protocol::block_header& block::header() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block.header)
  return header_ != NULL ? *header_ : *default_instance_->header_;
}
inline ::libbitcoin::protocol::block_header* block::mutable_header() {
  set_has_header();
  if (header_ == NULL) header_ = new ::libbitcoin::protocol::block_header;
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.block.header)
  return header_;
}
inline ::libbitcoin::protocol::block_header* block::release_header() {
  clear_has_header();
  ::libbitcoin::protocol::block_header* temp = header_;
  header_ = NULL;
  return temp;
}
inline void block::set_allocated_header(::libbitcoin::protocol::block_header* header) {
  delete header_;
  header_ = header;
  if (header) {
    set_has_header();
  } else {
    clear_has_header();
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.block.header)
}

// repeated .libbitcoin.protocol.tx transactions = 2;
inline int block::transactions_size() const {
  return transactions_.size();
}
inline void block::clear_transactions() {
  transactions_.Clear();
}
inline const ::libbitcoin::protocol::tx& block::transactions(int index) const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block.transactions)
  return transactions_.Get(index);
}
inline ::libbitcoin::protocol::tx* block::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.block.transactions)
  return transactions_.Mutable(index);
}
inline ::libbitcoin::protocol::tx* block::add_transactions() {
  // @@protoc_insertion_point(field_add:libbitcoin.protocol.block.transactions)
  return transactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx >&
block::transactions() const {
  // @@protoc_insertion_point(field_list:libbitcoin.protocol.block.transactions)
  return transactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx >*
block::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:libbitcoin.protocol.block.transactions)
  return &transactions_;
}

// repeated bytes tree = 3;
inline int block::tree_size() const {
  return tree_.size();
}
inline void block::clear_tree() {
  tree_.Clear();
}
inline const ::std::string& block::tree(int index) const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block.tree)
  return tree_.Get(index);
}
inline ::std::string* block::mutable_tree(int index) {
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.block.tree)
  return tree_.Mutable(index);
}
inline void block::set_tree(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.block.tree)
  tree_.Mutable(index)->assign(value);
}
inline void block::set_tree(int index, const char* value) {
  tree_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:libbitcoin.protocol.block.tree)
}
inline void block::set_tree(int index, const void* value, size_t size) {
  tree_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:libbitcoin.protocol.block.tree)
}
inline ::std::string* block::add_tree() {
  return tree_.Add();
}
inline void block::add_tree(const ::std::string& value) {
  tree_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:libbitcoin.protocol.block.tree)
}
inline void block::add_tree(const char* value) {
  tree_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:libbitcoin.protocol.block.tree)
}
inline void block::add_tree(const void* value, size_t size) {
  tree_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:libbitcoin.protocol.block.tree)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
block::tree() const {
  // @@protoc_insertion_point(field_list:libbitcoin.protocol.block.tree)
  return tree_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
block::mutable_tree() {
  // @@protoc_insertion_point(field_mutable_list:libbitcoin.protocol.block.tree)
  return &tree_;
}

// -------------------------------------------------------------------

// filter

// required .libbitcoin.protocol.filters filter_type = 1;
inline bool filter::has_filter_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void filter::set_has_filter_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void filter::clear_has_filter_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void filter::clear_filter_type() {
  filter_type_ = 1;
  clear_has_filter_type();
}
inline ::libbitcoin::protocol::filters filter::filter_type() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.filter.filter_type)
  return static_cast< ::libbitcoin::protocol::filters >(filter_type_);
}
inline void filter::set_filter_type(::libbitcoin::protocol::filters value) {
  assert(::libbitcoin::protocol::filters_IsValid(value));
  set_has_filter_type();
  filter_type_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.filter.filter_type)
}

// optional uint32 bits = 2;
inline bool filter::has_bits() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void filter::set_has_bits() {
  _has_bits_[0] |= 0x00000002u;
}
inline void filter::clear_has_bits() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void filter::clear_bits() {
  bits_ = 0u;
  clear_has_bits();
}
inline ::google::protobuf::uint32 filter::bits() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.filter.bits)
  return bits_;
}
inline void filter::set_bits(::google::protobuf::uint32 value) {
  set_has_bits();
  bits_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.filter.bits)
}

// required bytes prefix = 3;
inline bool filter::has_prefix() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void filter::set_has_prefix() {
  _has_bits_[0] |= 0x00000004u;
}
inline void filter::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void filter::clear_prefix() {
  if (prefix_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefix_->clear();
  }
  clear_has_prefix();
}
inline const ::std::string& filter::prefix() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.filter.prefix)
  return *prefix_;
}
inline void filter::set_prefix(const ::std::string& value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.filter.prefix)
}
inline void filter::set_prefix(const char* value) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(value);
  // @@protoc_insertion_point(field_set_char:libbitcoin.protocol.filter.prefix)
}
inline void filter::set_prefix(const void* value, size_t size) {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefix_ = new ::std::string;
  }
  prefix_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:libbitcoin.protocol.filter.prefix)
}
inline ::std::string* filter::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    prefix_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.filter.prefix)
  return prefix_;
}
inline ::std::string* filter::release_prefix() {
  clear_has_prefix();
  if (prefix_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = prefix_;
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void filter::set_allocated_prefix(::std::string* prefix) {
  if (prefix_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete prefix_;
  }
  if (prefix) {
    set_has_prefix();
    prefix_ = prefix;
  } else {
    clear_has_prefix();
    prefix_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.filter.prefix)
}

// -------------------------------------------------------------------

// block_id

// optional uint32 height = 1;
inline bool block_id::has_height() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void block_id::set_has_height() {
  _has_bits_[0] |= 0x00000001u;
}
inline void block_id::clear_has_height() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void block_id::clear_height() {
  height_ = 0u;
  clear_has_height();
}
inline ::google::protobuf::uint32 block_id::height() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_id.height)
  return height_;
}
inline void block_id::set_height(::google::protobuf::uint32 value) {
  set_has_height();
  height_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.block_id.height)
}

// optional bytes hash = 2;
inline bool block_id::has_hash() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void block_id::set_has_hash() {
  _has_bits_[0] |= 0x00000002u;
}
inline void block_id::clear_has_hash() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void block_id::clear_hash() {
  if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& block_id::hash() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_id.hash)
  return *hash_;
}
inline void block_id::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.block_id.hash)
}
inline void block_id::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:libbitcoin.protocol.block_id.hash)
}
inline void block_id::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:libbitcoin.protocol.block_id.hash)
}
inline ::std::string* block_id::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.block_id.hash)
  return hash_;
}
inline ::std::string* block_id::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void block_id::set_allocated_hash(::std::string* hash) {
  if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hash_;
  }
  if (hash) {
    set_has_hash();
    hash_ = hash;
  } else {
    clear_has_hash();
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.block_id.hash)
}

// -------------------------------------------------------------------

// block_location

// optional .libbitcoin.protocol.block_id identity = 1;
inline bool block_location::has_identity() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void block_location::set_has_identity() {
  _has_bits_[0] |= 0x00000001u;
}
inline void block_location::clear_has_identity() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void block_location::clear_identity() {
  if (identity_ != NULL) identity_->::libbitcoin::protocol::block_id::Clear();
  clear_has_identity();
}
inline const ::libbitcoin::protocol::block_id& block_location::identity() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_location.identity)
  return identity_ != NULL ? *identity_ : *default_instance_->identity_;
}
inline ::libbitcoin::protocol::block_id* block_location::mutable_identity() {
  set_has_identity();
  if (identity_ == NULL) identity_ = new ::libbitcoin::protocol::block_id;
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.block_location.identity)
  return identity_;
}
inline ::libbitcoin::protocol::block_id* block_location::release_identity() {
  clear_has_identity();
  ::libbitcoin::protocol::block_id* temp = identity_;
  identity_ = NULL;
  return temp;
}
inline void block_location::set_allocated_identity(::libbitcoin::protocol::block_id* identity) {
  delete identity_;
  identity_ = identity;
  if (identity) {
    set_has_identity();
  } else {
    clear_has_identity();
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.block_location.identity)
}

// optional uint64 index = 2;
inline bool block_location::has_index() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void block_location::set_has_index() {
  _has_bits_[0] |= 0x00000002u;
}
inline void block_location::clear_has_index() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void block_location::clear_index() {
  index_ = GOOGLE_ULONGLONG(0);
  clear_has_index();
}
inline ::google::protobuf::uint64 block_location::index() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_location.index)
  return index_;
}
inline void block_location::set_index(::google::protobuf::uint64 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.block_location.index)
}

// repeated bytes branch = 3;
inline int block_location::branch_size() const {
  return branch_.size();
}
inline void block_location::clear_branch() {
  branch_.Clear();
}
inline const ::std::string& block_location::branch(int index) const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_location.branch)
  return branch_.Get(index);
}
inline ::std::string* block_location::mutable_branch(int index) {
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.block_location.branch)
  return branch_.Mutable(index);
}
inline void block_location::set_branch(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.block_location.branch)
  branch_.Mutable(index)->assign(value);
}
inline void block_location::set_branch(int index, const char* value) {
  branch_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:libbitcoin.protocol.block_location.branch)
}
inline void block_location::set_branch(int index, const void* value, size_t size) {
  branch_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:libbitcoin.protocol.block_location.branch)
}
inline ::std::string* block_location::add_branch() {
  return branch_.Add();
}
inline void block_location::add_branch(const ::std::string& value) {
  branch_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:libbitcoin.protocol.block_location.branch)
}
inline void block_location::add_branch(const char* value) {
  branch_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:libbitcoin.protocol.block_location.branch)
}
inline void block_location::add_branch(const void* value, size_t size) {
  branch_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:libbitcoin.protocol.block_location.branch)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
block_location::branch() const {
  // @@protoc_insertion_point(field_list:libbitcoin.protocol.block_location.branch)
  return branch_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
block_location::mutable_branch() {
  // @@protoc_insertion_point(field_mutable_list:libbitcoin.protocol.block_location.branch)
  return &branch_;
}

// -------------------------------------------------------------------

// tx_hash_result

// required bytes hash = 1;
inline bool tx_hash_result::has_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tx_hash_result::set_has_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tx_hash_result::clear_has_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tx_hash_result::clear_hash() {
  if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_->clear();
  }
  clear_has_hash();
}
inline const ::std::string& tx_hash_result::hash() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.tx_hash_result.hash)
  return *hash_;
}
inline void tx_hash_result::set_hash(const ::std::string& value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.tx_hash_result.hash)
}
inline void tx_hash_result::set_hash(const char* value) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:libbitcoin.protocol.tx_hash_result.hash)
}
inline void tx_hash_result::set_hash(const void* value, size_t size) {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:libbitcoin.protocol.tx_hash_result.hash)
}
inline ::std::string* tx_hash_result::mutable_hash() {
  set_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.tx_hash_result.hash)
  return hash_;
}
inline ::std::string* tx_hash_result::release_hash() {
  clear_has_hash();
  if (hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = hash_;
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void tx_hash_result::set_allocated_hash(::std::string* hash) {
  if (hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete hash_;
  }
  if (hash) {
    set_has_hash();
    hash_ = hash;
  } else {
    clear_has_hash();
    hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.tx_hash_result.hash)
}

// required .libbitcoin.protocol.block_location location = 2;
inline bool tx_hash_result::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tx_hash_result::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tx_hash_result::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tx_hash_result::clear_location() {
  if (location_ != NULL) location_->::libbitcoin::protocol::block_location::Clear();
  clear_has_location();
}
inline const ::libbitcoin::protocol::block_location& tx_hash_result::location() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.tx_hash_result.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::libbitcoin::protocol::block_location* tx_hash_result::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::libbitcoin::protocol::block_location;
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.tx_hash_result.location)
  return location_;
}
inline ::libbitcoin::protocol::block_location* tx_hash_result::release_location() {
  clear_has_location();
  ::libbitcoin::protocol::block_location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void tx_hash_result::set_allocated_location(::libbitcoin::protocol::block_location* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.tx_hash_result.location)
}

// -------------------------------------------------------------------

// tx_result

// required .libbitcoin.protocol.tx transaction = 1;
inline bool tx_result::has_transaction() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void tx_result::set_has_transaction() {
  _has_bits_[0] |= 0x00000001u;
}
inline void tx_result::clear_has_transaction() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void tx_result::clear_transaction() {
  if (transaction_ != NULL) transaction_->::libbitcoin::protocol::tx::Clear();
  clear_has_transaction();
}
inline const ::libbitcoin::protocol::tx& tx_result::transaction() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.tx_result.transaction)
  return transaction_ != NULL ? *transaction_ : *default_instance_->transaction_;
}
inline ::libbitcoin::protocol::tx* tx_result::mutable_transaction() {
  set_has_transaction();
  if (transaction_ == NULL) transaction_ = new ::libbitcoin::protocol::tx;
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.tx_result.transaction)
  return transaction_;
}
inline ::libbitcoin::protocol::tx* tx_result::release_transaction() {
  clear_has_transaction();
  ::libbitcoin::protocol::tx* temp = transaction_;
  transaction_ = NULL;
  return temp;
}
inline void tx_result::set_allocated_transaction(::libbitcoin::protocol::tx* transaction) {
  delete transaction_;
  transaction_ = transaction;
  if (transaction) {
    set_has_transaction();
  } else {
    clear_has_transaction();
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.tx_result.transaction)
}

// required .libbitcoin.protocol.block_location location = 2;
inline bool tx_result::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void tx_result::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void tx_result::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void tx_result::clear_location() {
  if (location_ != NULL) location_->::libbitcoin::protocol::block_location::Clear();
  clear_has_location();
}
inline const ::libbitcoin::protocol::block_location& tx_result::location() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.tx_result.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::libbitcoin::protocol::block_location* tx_result::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::libbitcoin::protocol::block_location;
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.tx_result.location)
  return location_;
}
inline ::libbitcoin::protocol::block_location* tx_result::release_location() {
  clear_has_location();
  ::libbitcoin::protocol::block_location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void tx_result::set_allocated_location(::libbitcoin::protocol::block_location* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.tx_result.location)
}

// -------------------------------------------------------------------

// output

// required uint32 index = 1;
inline bool output::has_index() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void output::set_has_index() {
  _has_bits_[0] |= 0x00000001u;
}
inline void output::clear_has_index() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void output::clear_index() {
  index_ = 0u;
  clear_has_index();
}
inline ::google::protobuf::uint32 output::index() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.output.index)
  return index_;
}
inline void output::set_index(::google::protobuf::uint32 value) {
  set_has_index();
  index_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.output.index)
}

// required uint64 satoshis = 2;
inline bool output::has_satoshis() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void output::set_has_satoshis() {
  _has_bits_[0] |= 0x00000002u;
}
inline void output::clear_has_satoshis() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void output::clear_satoshis() {
  satoshis_ = GOOGLE_ULONGLONG(0);
  clear_has_satoshis();
}
inline ::google::protobuf::uint64 output::satoshis() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.output.satoshis)
  return satoshis_;
}
inline void output::set_satoshis(::google::protobuf::uint64 value) {
  set_has_satoshis();
  satoshis_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.output.satoshis)
}

// required bytes script = 3;
inline bool output::has_script() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void output::set_has_script() {
  _has_bits_[0] |= 0x00000004u;
}
inline void output::clear_has_script() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void output::clear_script() {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_->clear();
  }
  clear_has_script();
}
inline const ::std::string& output::script() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.output.script)
  return *script_;
}
inline void output::set_script(const ::std::string& value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(value);
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.output.script)
}
inline void output::set_script(const char* value) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(value);
  // @@protoc_insertion_point(field_set_char:libbitcoin.protocol.output.script)
}
inline void output::set_script(const void* value, size_t size) {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  script_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:libbitcoin.protocol.output.script)
}
inline ::std::string* output::mutable_script() {
  set_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    script_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.output.script)
  return script_;
}
inline ::std::string* output::release_script() {
  clear_has_script();
  if (script_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = script_;
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void output::set_allocated_script(::std::string* script) {
  if (script_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete script_;
  }
  if (script) {
    set_has_script();
    script_ = script;
  } else {
    clear_has_script();
    script_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.output.script)
}

// -------------------------------------------------------------------

// utxo_result

// required bytes tx_hash = 1;
inline bool utxo_result::has_tx_hash() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void utxo_result::set_has_tx_hash() {
  _has_bits_[0] |= 0x00000001u;
}
inline void utxo_result::clear_has_tx_hash() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void utxo_result::clear_tx_hash() {
  if (tx_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_hash_->clear();
  }
  clear_has_tx_hash();
}
inline const ::std::string& utxo_result::tx_hash() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.utxo_result.tx_hash)
  return *tx_hash_;
}
inline void utxo_result::set_tx_hash(const ::std::string& value) {
  set_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_hash_ = new ::std::string;
  }
  tx_hash_->assign(value);
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.utxo_result.tx_hash)
}
inline void utxo_result::set_tx_hash(const char* value) {
  set_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_hash_ = new ::std::string;
  }
  tx_hash_->assign(value);
  // @@protoc_insertion_point(field_set_char:libbitcoin.protocol.utxo_result.tx_hash)
}
inline void utxo_result::set_tx_hash(const void* value, size_t size) {
  set_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_hash_ = new ::std::string;
  }
  tx_hash_->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:libbitcoin.protocol.utxo_result.tx_hash)
}
inline ::std::string* utxo_result::mutable_tx_hash() {
  set_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    tx_hash_ = new ::std::string;
  }
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.utxo_result.tx_hash)
  return tx_hash_;
}
inline ::std::string* utxo_result::release_tx_hash() {
  clear_has_tx_hash();
  if (tx_hash_ == &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    return NULL;
  } else {
    ::std::string* temp = tx_hash_;
    tx_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    return temp;
  }
}
inline void utxo_result::set_allocated_tx_hash(::std::string* tx_hash) {
  if (tx_hash_ != &::google::protobuf::internal::GetEmptyStringAlreadyInited()) {
    delete tx_hash_;
  }
  if (tx_hash) {
    set_has_tx_hash();
    tx_hash_ = tx_hash;
  } else {
    clear_has_tx_hash();
    tx_hash_ = const_cast< ::std::string*>(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.utxo_result.tx_hash)
}

// required .libbitcoin.protocol.block_location location = 2;
inline bool utxo_result::has_location() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void utxo_result::set_has_location() {
  _has_bits_[0] |= 0x00000002u;
}
inline void utxo_result::clear_has_location() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void utxo_result::clear_location() {
  if (location_ != NULL) location_->::libbitcoin::protocol::block_location::Clear();
  clear_has_location();
}
inline const ::libbitcoin::protocol::block_location& utxo_result::location() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.utxo_result.location)
  return location_ != NULL ? *location_ : *default_instance_->location_;
}
inline ::libbitcoin::protocol::block_location* utxo_result::mutable_location() {
  set_has_location();
  if (location_ == NULL) location_ = new ::libbitcoin::protocol::block_location;
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.utxo_result.location)
  return location_;
}
inline ::libbitcoin::protocol::block_location* utxo_result::release_location() {
  clear_has_location();
  ::libbitcoin::protocol::block_location* temp = location_;
  location_ = NULL;
  return temp;
}
inline void utxo_result::set_allocated_location(::libbitcoin::protocol::block_location* location) {
  delete location_;
  location_ = location;
  if (location) {
    set_has_location();
  } else {
    clear_has_location();
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.utxo_result.location)
}

// repeated .libbitcoin.protocol.output outputs = 3;
inline int utxo_result::outputs_size() const {
  return outputs_.size();
}
inline void utxo_result::clear_outputs() {
  outputs_.Clear();
}
inline const ::libbitcoin::protocol::output& utxo_result::outputs(int index) const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.utxo_result.outputs)
  return outputs_.Get(index);
}
inline ::libbitcoin::protocol::output* utxo_result::mutable_outputs(int index) {
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.utxo_result.outputs)
  return outputs_.Mutable(index);
}
inline ::libbitcoin::protocol::output* utxo_result::add_outputs() {
  // @@protoc_insertion_point(field_add:libbitcoin.protocol.utxo_result.outputs)
  return outputs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::output >&
utxo_result::outputs() const {
  // @@protoc_insertion_point(field_list:libbitcoin.protocol.utxo_result.outputs)
  return outputs_;
}
inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::output >*
utxo_result::mutable_outputs() {
  // @@protoc_insertion_point(field_mutable_list:libbitcoin.protocol.utxo_result.outputs)
  return &outputs_;
}

// -------------------------------------------------------------------

// block_headers_request

// optional .libbitcoin.protocol.block_id start = 1;
inline bool block_headers_request::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void block_headers_request::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void block_headers_request::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void block_headers_request::clear_start() {
  if (start_ != NULL) start_->::libbitcoin::protocol::block_id::Clear();
  clear_has_start();
}
inline const ::libbitcoin::protocol::block_id& block_headers_request::start() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_headers_request.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::libbitcoin::protocol::block_id* block_headers_request::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::libbitcoin::protocol::block_id;
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.block_headers_request.start)
  return start_;
}
inline ::libbitcoin::protocol::block_id* block_headers_request::release_start() {
  clear_has_start();
  ::libbitcoin::protocol::block_id* temp = start_;
  start_ = NULL;
  return temp;
}
inline void block_headers_request::set_allocated_start(::libbitcoin::protocol::block_id* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.block_headers_request.start)
}

// optional uint32 results_per_page = 2;
inline bool block_headers_request::has_results_per_page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void block_headers_request::set_has_results_per_page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void block_headers_request::clear_has_results_per_page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void block_headers_request::clear_results_per_page() {
  results_per_page_ = 0u;
  clear_has_results_per_page();
}
inline ::google::protobuf::uint32 block_headers_request::results_per_page() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.block_headers_request.results_per_page)
  return results_per_page_;
}
inline void block_headers_request::set_results_per_page(::google::protobuf::uint32 value) {
  set_has_results_per_page();
  results_per_page_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.block_headers_request.results_per_page)
}

// -------------------------------------------------------------------

// transactions_request

// optional .libbitcoin.protocol.block_id start = 1;
inline bool transactions_request::has_start() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void transactions_request::set_has_start() {
  _has_bits_[0] |= 0x00000001u;
}
inline void transactions_request::clear_has_start() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void transactions_request::clear_start() {
  if (start_ != NULL) start_->::libbitcoin::protocol::block_id::Clear();
  clear_has_start();
}
inline const ::libbitcoin::protocol::block_id& transactions_request::start() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.transactions_request.start)
  return start_ != NULL ? *start_ : *default_instance_->start_;
}
inline ::libbitcoin::protocol::block_id* transactions_request::mutable_start() {
  set_has_start();
  if (start_ == NULL) start_ = new ::libbitcoin::protocol::block_id;
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.transactions_request.start)
  return start_;
}
inline ::libbitcoin::protocol::block_id* transactions_request::release_start() {
  clear_has_start();
  ::libbitcoin::protocol::block_id* temp = start_;
  start_ = NULL;
  return temp;
}
inline void transactions_request::set_allocated_start(::libbitcoin::protocol::block_id* start) {
  delete start_;
  start_ = start;
  if (start) {
    set_has_start();
  } else {
    clear_has_start();
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.transactions_request.start)
}

// optional uint32 results_per_page = 2;
inline bool transactions_request::has_results_per_page() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void transactions_request::set_has_results_per_page() {
  _has_bits_[0] |= 0x00000002u;
}
inline void transactions_request::clear_has_results_per_page() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void transactions_request::clear_results_per_page() {
  results_per_page_ = 0u;
  clear_has_results_per_page();
}
inline ::google::protobuf::uint32 transactions_request::results_per_page() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.transactions_request.results_per_page)
  return results_per_page_;
}
inline void transactions_request::set_results_per_page(::google::protobuf::uint32 value) {
  set_has_results_per_page();
  results_per_page_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.transactions_request.results_per_page)
}

// repeated .libbitcoin.protocol.filter query = 3;
inline int transactions_request::query_size() const {
  return query_.size();
}
inline void transactions_request::clear_query() {
  query_.Clear();
}
inline const ::libbitcoin::protocol::filter& transactions_request::query(int index) const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.transactions_request.query)
  return query_.Get(index);
}
inline ::libbitcoin::protocol::filter* transactions_request::mutable_query(int index) {
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.transactions_request.query)
  return query_.Mutable(index);
}
inline ::libbitcoin::protocol::filter* transactions_request::add_query() {
  // @@protoc_insertion_point(field_add:libbitcoin.protocol.transactions_request.query)
  return query_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::filter >&
transactions_request::query() const {
  // @@protoc_insertion_point(field_list:libbitcoin.protocol.transactions_request.query)
  return query_;
}
inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::filter >*
transactions_request::mutable_query() {
  // @@protoc_insertion_point(field_mutable_list:libbitcoin.protocol.transactions_request.query)
  return &query_;
}

// optional .libbitcoin.protocol.transaction_results result_type = 4 [default = TX_HASH];
inline bool transactions_request::has_result_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void transactions_request::set_has_result_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void transactions_request::clear_has_result_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void transactions_request::clear_result_type() {
  result_type_ = 1;
  clear_has_result_type();
}
inline ::libbitcoin::protocol::transaction_results transactions_request::result_type() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.transactions_request.result_type)
  return static_cast< ::libbitcoin::protocol::transaction_results >(result_type_);
}
inline void transactions_request::set_result_type(::libbitcoin::protocol::transaction_results value) {
  assert(::libbitcoin::protocol::transaction_results_IsValid(value));
  set_has_result_type();
  result_type_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.transactions_request.result_type)
}

// optional .libbitcoin.protocol.locations location_type = 5 [default = NONE];
inline bool transactions_request::has_location_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void transactions_request::set_has_location_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void transactions_request::clear_has_location_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void transactions_request::clear_location_type() {
  location_type_ = 0;
  clear_has_location_type();
}
inline ::libbitcoin::protocol::locations transactions_request::location_type() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.transactions_request.location_type)
  return static_cast< ::libbitcoin::protocol::locations >(location_type_);
}
inline void transactions_request::set_location_type(::libbitcoin::protocol::locations value) {
  assert(::libbitcoin::protocol::locations_IsValid(value));
  set_has_location_type();
  location_type_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.transactions_request.location_type)
}

// -------------------------------------------------------------------

// request

// required uint32 id = 1;
inline bool request::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void request::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void request::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void request::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 request::id() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.request.id)
  return id_;
}
inline void request::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.request.id)
}

// optional .libbitcoin.protocol.block_headers_request get_block_headers = 2;
inline bool request::has_get_block_headers() const {
  return request_type_case() == kGetBlockHeaders;
}
inline void request::set_has_get_block_headers() {
  _oneof_case_[0] = kGetBlockHeaders;
}
inline void request::clear_get_block_headers() {
  if (has_get_block_headers()) {
    delete request_type_.get_block_headers_;
    clear_has_request_type();
  }
}
inline const ::libbitcoin::protocol::block_headers_request& request::get_block_headers() const {
  return has_get_block_headers() ? *request_type_.get_block_headers_
                      : ::libbitcoin::protocol::block_headers_request::default_instance();
}
inline ::libbitcoin::protocol::block_headers_request* request::mutable_get_block_headers() {
  if (!has_get_block_headers()) {
    clear_request_type();
    set_has_get_block_headers();
    request_type_.get_block_headers_ = new ::libbitcoin::protocol::block_headers_request;
  }
  return request_type_.get_block_headers_;
}
inline ::libbitcoin::protocol::block_headers_request* request::release_get_block_headers() {
  if (has_get_block_headers()) {
    clear_has_request_type();
    ::libbitcoin::protocol::block_headers_request* temp = request_type_.get_block_headers_;
    request_type_.get_block_headers_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void request::set_allocated_get_block_headers(::libbitcoin::protocol::block_headers_request* get_block_headers) {
  clear_request_type();
  if (get_block_headers) {
    set_has_get_block_headers();
    request_type_.get_block_headers_ = get_block_headers;
  }
}

// optional .libbitcoin.protocol.transactions_request get_transactions = 3;
inline bool request::has_get_transactions() const {
  return request_type_case() == kGetTransactions;
}
inline void request::set_has_get_transactions() {
  _oneof_case_[0] = kGetTransactions;
}
inline void request::clear_get_transactions() {
  if (has_get_transactions()) {
    delete request_type_.get_transactions_;
    clear_has_request_type();
  }
}
inline const ::libbitcoin::protocol::transactions_request& request::get_transactions() const {
  return has_get_transactions() ? *request_type_.get_transactions_
                      : ::libbitcoin::protocol::transactions_request::default_instance();
}
inline ::libbitcoin::protocol::transactions_request* request::mutable_get_transactions() {
  if (!has_get_transactions()) {
    clear_request_type();
    set_has_get_transactions();
    request_type_.get_transactions_ = new ::libbitcoin::protocol::transactions_request;
  }
  return request_type_.get_transactions_;
}
inline ::libbitcoin::protocol::transactions_request* request::release_get_transactions() {
  if (has_get_transactions()) {
    clear_has_request_type();
    ::libbitcoin::protocol::transactions_request* temp = request_type_.get_transactions_;
    request_type_.get_transactions_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void request::set_allocated_get_transactions(::libbitcoin::protocol::transactions_request* get_transactions) {
  clear_request_type();
  if (get_transactions) {
    set_has_get_transactions();
    request_type_.get_transactions_ = get_transactions;
  }
}

// optional .libbitcoin.protocol.tx post_transaction = 4;
inline bool request::has_post_transaction() const {
  return request_type_case() == kPostTransaction;
}
inline void request::set_has_post_transaction() {
  _oneof_case_[0] = kPostTransaction;
}
inline void request::clear_post_transaction() {
  if (has_post_transaction()) {
    delete request_type_.post_transaction_;
    clear_has_request_type();
  }
}
inline const ::libbitcoin::protocol::tx& request::post_transaction() const {
  return has_post_transaction() ? *request_type_.post_transaction_
                      : ::libbitcoin::protocol::tx::default_instance();
}
inline ::libbitcoin::protocol::tx* request::mutable_post_transaction() {
  if (!has_post_transaction()) {
    clear_request_type();
    set_has_post_transaction();
    request_type_.post_transaction_ = new ::libbitcoin::protocol::tx;
  }
  return request_type_.post_transaction_;
}
inline ::libbitcoin::protocol::tx* request::release_post_transaction() {
  if (has_post_transaction()) {
    clear_has_request_type();
    ::libbitcoin::protocol::tx* temp = request_type_.post_transaction_;
    request_type_.post_transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void request::set_allocated_post_transaction(::libbitcoin::protocol::tx* post_transaction) {
  clear_request_type();
  if (post_transaction) {
    set_has_post_transaction();
    request_type_.post_transaction_ = post_transaction;
  }
}

// optional .libbitcoin.protocol.tx validate_transaction = 5;
inline bool request::has_validate_transaction() const {
  return request_type_case() == kValidateTransaction;
}
inline void request::set_has_validate_transaction() {
  _oneof_case_[0] = kValidateTransaction;
}
inline void request::clear_validate_transaction() {
  if (has_validate_transaction()) {
    delete request_type_.validate_transaction_;
    clear_has_request_type();
  }
}
inline const ::libbitcoin::protocol::tx& request::validate_transaction() const {
  return has_validate_transaction() ? *request_type_.validate_transaction_
                      : ::libbitcoin::protocol::tx::default_instance();
}
inline ::libbitcoin::protocol::tx* request::mutable_validate_transaction() {
  if (!has_validate_transaction()) {
    clear_request_type();
    set_has_validate_transaction();
    request_type_.validate_transaction_ = new ::libbitcoin::protocol::tx;
  }
  return request_type_.validate_transaction_;
}
inline ::libbitcoin::protocol::tx* request::release_validate_transaction() {
  if (has_validate_transaction()) {
    clear_has_request_type();
    ::libbitcoin::protocol::tx* temp = request_type_.validate_transaction_;
    request_type_.validate_transaction_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void request::set_allocated_validate_transaction(::libbitcoin::protocol::tx* validate_transaction) {
  clear_request_type();
  if (validate_transaction) {
    set_has_validate_transaction();
    request_type_.validate_transaction_ = validate_transaction;
  }
}

// optional .libbitcoin.protocol.block post_block = 6;
inline bool request::has_post_block() const {
  return request_type_case() == kPostBlock;
}
inline void request::set_has_post_block() {
  _oneof_case_[0] = kPostBlock;
}
inline void request::clear_post_block() {
  if (has_post_block()) {
    delete request_type_.post_block_;
    clear_has_request_type();
  }
}
inline const ::libbitcoin::protocol::block& request::post_block() const {
  return has_post_block() ? *request_type_.post_block_
                      : ::libbitcoin::protocol::block::default_instance();
}
inline ::libbitcoin::protocol::block* request::mutable_post_block() {
  if (!has_post_block()) {
    clear_request_type();
    set_has_post_block();
    request_type_.post_block_ = new ::libbitcoin::protocol::block;
  }
  return request_type_.post_block_;
}
inline ::libbitcoin::protocol::block* request::release_post_block() {
  if (has_post_block()) {
    clear_has_request_type();
    ::libbitcoin::protocol::block* temp = request_type_.post_block_;
    request_type_.post_block_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void request::set_allocated_post_block(::libbitcoin::protocol::block* post_block) {
  clear_request_type();
  if (post_block) {
    set_has_post_block();
    request_type_.post_block_ = post_block;
  }
}

// optional .libbitcoin.protocol.block validate_block = 7;
inline bool request::has_validate_block() const {
  return request_type_case() == kValidateBlock;
}
inline void request::set_has_validate_block() {
  _oneof_case_[0] = kValidateBlock;
}
inline void request::clear_validate_block() {
  if (has_validate_block()) {
    delete request_type_.validate_block_;
    clear_has_request_type();
  }
}
inline const ::libbitcoin::protocol::block& request::validate_block() const {
  return has_validate_block() ? *request_type_.validate_block_
                      : ::libbitcoin::protocol::block::default_instance();
}
inline ::libbitcoin::protocol::block* request::mutable_validate_block() {
  if (!has_validate_block()) {
    clear_request_type();
    set_has_validate_block();
    request_type_.validate_block_ = new ::libbitcoin::protocol::block;
  }
  return request_type_.validate_block_;
}
inline ::libbitcoin::protocol::block* request::release_validate_block() {
  if (has_validate_block()) {
    clear_has_request_type();
    ::libbitcoin::protocol::block* temp = request_type_.validate_block_;
    request_type_.validate_block_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void request::set_allocated_validate_block(::libbitcoin::protocol::block* validate_block) {
  clear_request_type();
  if (validate_block) {
    set_has_validate_block();
    request_type_.validate_block_ = validate_block;
  }
}

inline bool request::has_request_type() {
  return request_type_case() != REQUEST_TYPE_NOT_SET;
}
inline void request::clear_has_request_type() {
  _oneof_case_[0] = REQUEST_TYPE_NOT_SET;
}
inline request::RequestTypeCase request::request_type_case() const {
  return request::RequestTypeCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// response_block_headers

// optional .libbitcoin.protocol.block_id next = 1;
inline bool response_block_headers::has_next() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void response_block_headers::set_has_next() {
  _has_bits_[0] |= 0x00000001u;
}
inline void response_block_headers::clear_has_next() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void response_block_headers::clear_next() {
  if (next_ != NULL) next_->::libbitcoin::protocol::block_id::Clear();
  clear_has_next();
}
inline const ::libbitcoin::protocol::block_id& response_block_headers::next() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.response.block_headers.next)
  return next_ != NULL ? *next_ : *default_instance_->next_;
}
inline ::libbitcoin::protocol::block_id* response_block_headers::mutable_next() {
  set_has_next();
  if (next_ == NULL) next_ = new ::libbitcoin::protocol::block_id;
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.response.block_headers.next)
  return next_;
}
inline ::libbitcoin::protocol::block_id* response_block_headers::release_next() {
  clear_has_next();
  ::libbitcoin::protocol::block_id* temp = next_;
  next_ = NULL;
  return temp;
}
inline void response_block_headers::set_allocated_next(::libbitcoin::protocol::block_id* next) {
  delete next_;
  next_ = next;
  if (next) {
    set_has_next();
  } else {
    clear_has_next();
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.response.block_headers.next)
}

// optional .libbitcoin.protocol.block_id top = 2;
inline bool response_block_headers::has_top() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void response_block_headers::set_has_top() {
  _has_bits_[0] |= 0x00000002u;
}
inline void response_block_headers::clear_has_top() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void response_block_headers::clear_top() {
  if (top_ != NULL) top_->::libbitcoin::protocol::block_id::Clear();
  clear_has_top();
}
inline const ::libbitcoin::protocol::block_id& response_block_headers::top() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.response.block_headers.top)
  return top_ != NULL ? *top_ : *default_instance_->top_;
}
inline ::libbitcoin::protocol::block_id* response_block_headers::mutable_top() {
  set_has_top();
  if (top_ == NULL) top_ = new ::libbitcoin::protocol::block_id;
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.response.block_headers.top)
  return top_;
}
inline ::libbitcoin::protocol::block_id* response_block_headers::release_top() {
  clear_has_top();
  ::libbitcoin::protocol::block_id* temp = top_;
  top_ = NULL;
  return temp;
}
inline void response_block_headers::set_allocated_top(::libbitcoin::protocol::block_id* top) {
  delete top_;
  top_ = top;
  if (top) {
    set_has_top();
  } else {
    clear_has_top();
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.response.block_headers.top)
}

// repeated .libbitcoin.protocol.block_header headers = 3;
inline int response_block_headers::headers_size() const {
  return headers_.size();
}
inline void response_block_headers::clear_headers() {
  headers_.Clear();
}
inline const ::libbitcoin::protocol::block_header& response_block_headers::headers(int index) const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.response.block_headers.headers)
  return headers_.Get(index);
}
inline ::libbitcoin::protocol::block_header* response_block_headers::mutable_headers(int index) {
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.response.block_headers.headers)
  return headers_.Mutable(index);
}
inline ::libbitcoin::protocol::block_header* response_block_headers::add_headers() {
  // @@protoc_insertion_point(field_add:libbitcoin.protocol.response.block_headers.headers)
  return headers_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::block_header >&
response_block_headers::headers() const {
  // @@protoc_insertion_point(field_list:libbitcoin.protocol.response.block_headers.headers)
  return headers_;
}
inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::block_header >*
response_block_headers::mutable_headers() {
  // @@protoc_insertion_point(field_mutable_list:libbitcoin.protocol.response.block_headers.headers)
  return &headers_;
}

// -------------------------------------------------------------------

// response_transactions

// optional .libbitcoin.protocol.block_id next = 1;
inline bool response_transactions::has_next() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void response_transactions::set_has_next() {
  _has_bits_[0] |= 0x00000001u;
}
inline void response_transactions::clear_has_next() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void response_transactions::clear_next() {
  if (next_ != NULL) next_->::libbitcoin::protocol::block_id::Clear();
  clear_has_next();
}
inline const ::libbitcoin::protocol::block_id& response_transactions::next() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.response.transactions.next)
  return next_ != NULL ? *next_ : *default_instance_->next_;
}
inline ::libbitcoin::protocol::block_id* response_transactions::mutable_next() {
  set_has_next();
  if (next_ == NULL) next_ = new ::libbitcoin::protocol::block_id;
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.response.transactions.next)
  return next_;
}
inline ::libbitcoin::protocol::block_id* response_transactions::release_next() {
  clear_has_next();
  ::libbitcoin::protocol::block_id* temp = next_;
  next_ = NULL;
  return temp;
}
inline void response_transactions::set_allocated_next(::libbitcoin::protocol::block_id* next) {
  delete next_;
  next_ = next;
  if (next) {
    set_has_next();
  } else {
    clear_has_next();
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.response.transactions.next)
}

// optional .libbitcoin.protocol.block_id top = 2;
inline bool response_transactions::has_top() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void response_transactions::set_has_top() {
  _has_bits_[0] |= 0x00000002u;
}
inline void response_transactions::clear_has_top() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void response_transactions::clear_top() {
  if (top_ != NULL) top_->::libbitcoin::protocol::block_id::Clear();
  clear_has_top();
}
inline const ::libbitcoin::protocol::block_id& response_transactions::top() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.response.transactions.top)
  return top_ != NULL ? *top_ : *default_instance_->top_;
}
inline ::libbitcoin::protocol::block_id* response_transactions::mutable_top() {
  set_has_top();
  if (top_ == NULL) top_ = new ::libbitcoin::protocol::block_id;
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.response.transactions.top)
  return top_;
}
inline ::libbitcoin::protocol::block_id* response_transactions::release_top() {
  clear_has_top();
  ::libbitcoin::protocol::block_id* temp = top_;
  top_ = NULL;
  return temp;
}
inline void response_transactions::set_allocated_top(::libbitcoin::protocol::block_id* top) {
  delete top_;
  top_ = top;
  if (top) {
    set_has_top();
  } else {
    clear_has_top();
  }
  // @@protoc_insertion_point(field_set_allocated:libbitcoin.protocol.response.transactions.top)
}

// repeated .libbitcoin.protocol.tx_hash_result hashes = 3;
inline int response_transactions::hashes_size() const {
  return hashes_.size();
}
inline void response_transactions::clear_hashes() {
  hashes_.Clear();
}
inline const ::libbitcoin::protocol::tx_hash_result& response_transactions::hashes(int index) const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.response.transactions.hashes)
  return hashes_.Get(index);
}
inline ::libbitcoin::protocol::tx_hash_result* response_transactions::mutable_hashes(int index) {
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.response.transactions.hashes)
  return hashes_.Mutable(index);
}
inline ::libbitcoin::protocol::tx_hash_result* response_transactions::add_hashes() {
  // @@protoc_insertion_point(field_add:libbitcoin.protocol.response.transactions.hashes)
  return hashes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_hash_result >&
response_transactions::hashes() const {
  // @@protoc_insertion_point(field_list:libbitcoin.protocol.response.transactions.hashes)
  return hashes_;
}
inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_hash_result >*
response_transactions::mutable_hashes() {
  // @@protoc_insertion_point(field_mutable_list:libbitcoin.protocol.response.transactions.hashes)
  return &hashes_;
}

// repeated .libbitcoin.protocol.tx_result transactions = 4;
inline int response_transactions::transactions_size() const {
  return transactions_.size();
}
inline void response_transactions::clear_transactions() {
  transactions_.Clear();
}
inline const ::libbitcoin::protocol::tx_result& response_transactions::transactions(int index) const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.response.transactions.transactions)
  return transactions_.Get(index);
}
inline ::libbitcoin::protocol::tx_result* response_transactions::mutable_transactions(int index) {
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.response.transactions.transactions)
  return transactions_.Mutable(index);
}
inline ::libbitcoin::protocol::tx_result* response_transactions::add_transactions() {
  // @@protoc_insertion_point(field_add:libbitcoin.protocol.response.transactions.transactions)
  return transactions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_result >&
response_transactions::transactions() const {
  // @@protoc_insertion_point(field_list:libbitcoin.protocol.response.transactions.transactions)
  return transactions_;
}
inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::tx_result >*
response_transactions::mutable_transactions() {
  // @@protoc_insertion_point(field_mutable_list:libbitcoin.protocol.response.transactions.transactions)
  return &transactions_;
}

// repeated .libbitcoin.protocol.utxo_result utxos = 5;
inline int response_transactions::utxos_size() const {
  return utxos_.size();
}
inline void response_transactions::clear_utxos() {
  utxos_.Clear();
}
inline const ::libbitcoin::protocol::utxo_result& response_transactions::utxos(int index) const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.response.transactions.utxos)
  return utxos_.Get(index);
}
inline ::libbitcoin::protocol::utxo_result* response_transactions::mutable_utxos(int index) {
  // @@protoc_insertion_point(field_mutable:libbitcoin.protocol.response.transactions.utxos)
  return utxos_.Mutable(index);
}
inline ::libbitcoin::protocol::utxo_result* response_transactions::add_utxos() {
  // @@protoc_insertion_point(field_add:libbitcoin.protocol.response.transactions.utxos)
  return utxos_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::utxo_result >&
response_transactions::utxos() const {
  // @@protoc_insertion_point(field_list:libbitcoin.protocol.response.transactions.utxos)
  return utxos_;
}
inline ::google::protobuf::RepeatedPtrField< ::libbitcoin::protocol::utxo_result >*
response_transactions::mutable_utxos() {
  // @@protoc_insertion_point(field_mutable_list:libbitcoin.protocol.response.transactions.utxos)
  return &utxos_;
}

// -------------------------------------------------------------------

// response

// required uint32 id = 1;
inline bool response::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void response::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void response::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void response::clear_id() {
  id_ = 0u;
  clear_has_id();
}
inline ::google::protobuf::uint32 response::id() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.response.id)
  return id_;
}
inline void response::set_id(::google::protobuf::uint32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.response.id)
}

// optional sint32 status = 2;
inline bool response::has_status() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void response::set_has_status() {
  _has_bits_[0] |= 0x00000002u;
}
inline void response::clear_has_status() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void response::clear_status() {
  status_ = 0;
  clear_has_status();
}
inline ::google::protobuf::int32 response::status() const {
  // @@protoc_insertion_point(field_get:libbitcoin.protocol.response.status)
  return status_;
}
inline void response::set_status(::google::protobuf::int32 value) {
  set_has_status();
  status_ = value;
  // @@protoc_insertion_point(field_set:libbitcoin.protocol.response.status)
}

// optional .libbitcoin.protocol.response.block_headers get_block_headers_response = 3;
inline bool response::has_get_block_headers_response() const {
  return response_type_case() == kGetBlockHeadersResponse;
}
inline void response::set_has_get_block_headers_response() {
  _oneof_case_[0] = kGetBlockHeadersResponse;
}
inline void response::clear_get_block_headers_response() {
  if (has_get_block_headers_response()) {
    delete response_type_.get_block_headers_response_;
    clear_has_response_type();
  }
}
inline const ::libbitcoin::protocol::response_block_headers& response::get_block_headers_response() const {
  return has_get_block_headers_response() ? *response_type_.get_block_headers_response_
                      : ::libbitcoin::protocol::response_block_headers::default_instance();
}
inline ::libbitcoin::protocol::response_block_headers* response::mutable_get_block_headers_response() {
  if (!has_get_block_headers_response()) {
    clear_response_type();
    set_has_get_block_headers_response();
    response_type_.get_block_headers_response_ = new ::libbitcoin::protocol::response_block_headers;
  }
  return response_type_.get_block_headers_response_;
}
inline ::libbitcoin::protocol::response_block_headers* response::release_get_block_headers_response() {
  if (has_get_block_headers_response()) {
    clear_has_response_type();
    ::libbitcoin::protocol::response_block_headers* temp = response_type_.get_block_headers_response_;
    response_type_.get_block_headers_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void response::set_allocated_get_block_headers_response(::libbitcoin::protocol::response_block_headers* get_block_headers_response) {
  clear_response_type();
  if (get_block_headers_response) {
    set_has_get_block_headers_response();
    response_type_.get_block_headers_response_ = get_block_headers_response;
  }
}

// optional .libbitcoin.protocol.response.transactions get_transactions_response = 4;
inline bool response::has_get_transactions_response() const {
  return response_type_case() == kGetTransactionsResponse;
}
inline void response::set_has_get_transactions_response() {
  _oneof_case_[0] = kGetTransactionsResponse;
}
inline void response::clear_get_transactions_response() {
  if (has_get_transactions_response()) {
    delete response_type_.get_transactions_response_;
    clear_has_response_type();
  }
}
inline const ::libbitcoin::protocol::response_transactions& response::get_transactions_response() const {
  return has_get_transactions_response() ? *response_type_.get_transactions_response_
                      : ::libbitcoin::protocol::response_transactions::default_instance();
}
inline ::libbitcoin::protocol::response_transactions* response::mutable_get_transactions_response() {
  if (!has_get_transactions_response()) {
    clear_response_type();
    set_has_get_transactions_response();
    response_type_.get_transactions_response_ = new ::libbitcoin::protocol::response_transactions;
  }
  return response_type_.get_transactions_response_;
}
inline ::libbitcoin::protocol::response_transactions* response::release_get_transactions_response() {
  if (has_get_transactions_response()) {
    clear_has_response_type();
    ::libbitcoin::protocol::response_transactions* temp = response_type_.get_transactions_response_;
    response_type_.get_transactions_response_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void response::set_allocated_get_transactions_response(::libbitcoin::protocol::response_transactions* get_transactions_response) {
  clear_response_type();
  if (get_transactions_response) {
    set_has_get_transactions_response();
    response_type_.get_transactions_response_ = get_transactions_response;
  }
}

// optional bool post_transaction_succeeded = 5;
inline bool response::has_post_transaction_succeeded() const {
  return response_type_case() == kPostTransactionSucceeded;
}
inline void response::set_has_post_transaction_succeeded() {
  _oneof_case_[0] = kPostTransactionSucceeded;
}
inline void response::clear_post_transaction_succeeded() {
  if (has_post_transaction_succeeded()) {
    response_type_.post_transaction_succeeded_ = false;
    clear_has_response_type();
  }
}
inline bool response::post_transaction_succeeded() const {
  if (has_post_transaction_succeeded()) {
    return response_type_.post_transaction_succeeded_;
  }
  return false;
}
inline void response::set_post_transaction_succeeded(bool value) {
  if (!has_post_transaction_succeeded()) {
    clear_response_type();
    set_has_post_transaction_succeeded();
  }
  response_type_.post_transaction_succeeded_ = value;
}

// optional bool validate_transaction_succeeded = 6;
inline bool response::has_validate_transaction_succeeded() const {
  return response_type_case() == kValidateTransactionSucceeded;
}
inline void response::set_has_validate_transaction_succeeded() {
  _oneof_case_[0] = kValidateTransactionSucceeded;
}
inline void response::clear_validate_transaction_succeeded() {
  if (has_validate_transaction_succeeded()) {
    response_type_.validate_transaction_succeeded_ = false;
    clear_has_response_type();
  }
}
inline bool response::validate_transaction_succeeded() const {
  if (has_validate_transaction_succeeded()) {
    return response_type_.validate_transaction_succeeded_;
  }
  return false;
}
inline void response::set_validate_transaction_succeeded(bool value) {
  if (!has_validate_transaction_succeeded()) {
    clear_response_type();
    set_has_validate_transaction_succeeded();
  }
  response_type_.validate_transaction_succeeded_ = value;
}

// optional bool post_block_succeeded = 7;
inline bool response::has_post_block_succeeded() const {
  return response_type_case() == kPostBlockSucceeded;
}
inline void response::set_has_post_block_succeeded() {
  _oneof_case_[0] = kPostBlockSucceeded;
}
inline void response::clear_post_block_succeeded() {
  if (has_post_block_succeeded()) {
    response_type_.post_block_succeeded_ = false;
    clear_has_response_type();
  }
}
inline bool response::post_block_succeeded() const {
  if (has_post_block_succeeded()) {
    return response_type_.post_block_succeeded_;
  }
  return false;
}
inline void response::set_post_block_succeeded(bool value) {
  if (!has_post_block_succeeded()) {
    clear_response_type();
    set_has_post_block_succeeded();
  }
  response_type_.post_block_succeeded_ = value;
}

// optional bool validate_block_succeeded = 8;
inline bool response::has_validate_block_succeeded() const {
  return response_type_case() == kValidateBlockSucceeded;
}
inline void response::set_has_validate_block_succeeded() {
  _oneof_case_[0] = kValidateBlockSucceeded;
}
inline void response::clear_validate_block_succeeded() {
  if (has_validate_block_succeeded()) {
    response_type_.validate_block_succeeded_ = false;
    clear_has_response_type();
  }
}
inline bool response::validate_block_succeeded() const {
  if (has_validate_block_succeeded()) {
    return response_type_.validate_block_succeeded_;
  }
  return false;
}
inline void response::set_validate_block_succeeded(bool value) {
  if (!has_validate_block_succeeded()) {
    clear_response_type();
    set_has_validate_block_succeeded();
  }
  response_type_.validate_block_succeeded_ = value;
}

inline bool response::has_response_type() {
  return response_type_case() != RESPONSE_TYPE_NOT_SET;
}
inline void response::clear_has_response_type() {
  _oneof_case_[0] = RESPONSE_TYPE_NOT_SET;
}
inline response::ResponseTypeCase response::response_type_case() const {
  return response::ResponseTypeCase(_oneof_case_[0]);
}

// @@protoc_insertion_point(namespace_scope)

}  // namespace protocol
}  // namespace libbitcoin

#ifndef SWIG
namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::libbitcoin::protocol::filters> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::libbitcoin::protocol::filters>() {
  return ::libbitcoin::protocol::filters_descriptor();
}
template <> struct is_proto_enum< ::libbitcoin::protocol::transaction_results> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::libbitcoin::protocol::transaction_results>() {
  return ::libbitcoin::protocol::transaction_results_descriptor();
}
template <> struct is_proto_enum< ::libbitcoin::protocol::locations> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::libbitcoin::protocol::locations>() {
  return ::libbitcoin::protocol::locations_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_bitcoin_2fprotocol_2finterface_2eproto__INCLUDED
